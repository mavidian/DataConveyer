//OrchestratorConfig.cs
//
// Copyright © 2016-2019 Mavidian Technologies Limited Liability Company. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


using Mavidian.DataConveyer.Common;
using Mavidian.DataConveyer.Entities.KeyVal;
using Mavidian.DataConveyer.Logging;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using System.Xml;
using System.Xml.Serialization;

namespace Mavidian.DataConveyer.Orchestrators
{
   /// <summary>
   /// Configuration settings to be used by <see cref="OrchestratorCreator"/> when constructing an orchestrator
   /// instance, i.e an object that implements the <see cref="IOrchestrator"/> interface.
   /// </summary>
   public class OrchestratorConfig
   {
      //NOTE re: element types
      //This class is serialized using XML serializer (SaveConfig method).
      //It is important to ensure that types of all elements are serialized/deserialized properly, which
      // may necessitate special handling (e.g. TimeLimit property serialized via TimeLimit_ticks).


      /// <summary>
      /// Creates an instance of the configuration object with default initial values and no logging.
      /// </summary>
      public OrchestratorConfig() : this(LoggerCreator.CreateLogger()) { }


      /// <summary>
      /// Creates an instance of the configuration object with default initial values.
      /// </summary>
      /// <param name="logger">Logger to be used to process log entries generated by Data Conveyer, such as warnings or errors.</param>
      public OrchestratorConfig(ILogger logger)
      {
         Logger = logger;
         Logger.LogStart(ConfigName);
         SetInitialValues();
         Logger.LogInfo("Configuration initialized.");
      }


      /// <summary>
      /// Logger to process log entries generated by Data Conveyer, such as warnings or errors.
      /// </summary>
      internal ILogger Logger { get; private set; }

      
      //Default functions to be used if not explicitly set by the caller (note that for equality comparisons, delegates must refer to the same instance)
      //TODO: Consider making them private (unit tests will require refactoring)
      internal static Func<string, ItemDef> DefaultTypeDefiner = fn => new ItemDef(ItemType.String, null);
      internal static Func<IGlobalCache, Tuple<ExternalLine, int>> DefaultIntakeSupplier = gc => null;
      internal static Func<IGlobalCache, Task<Tuple<ExternalLine, int>>> DefaultAsyncIntakeSupplier = gc => Task.FromResult<Tuple<ExternalLine, int>>(null);
      //note that Task.FromResult<Tuple<string, int>>(null) is functionally the same as:
      // new Task<Tuple<string,int>>(gc => null), but more efficient (no scheduling overhead)
      internal static Func<IGlobalCache, string> DefaultIntakeInitializer = gc => null;
      internal static Action<IGlobalCache> DefaultIntakeDisposer = gc => { };
      internal static Func<IRecord, IDictionary<string, object>, bool> DefaultRecordInitiator = (rec, tb) => true;  //no updates to trace bin; start transformation
      internal static Func<IRecord, IRecord, int, bool> DefaultClusterMarker = (r, pr, i) => r.ClstrNo == 0 || pr == null || r.ClstrNo != pr.ClstrNo;
      // default marker splits clusters on every record; except that initial ClstrNo values (XML or JSON), if present, drive marker splits (MarkerStartsCluster must be true (default) for expected behavior)
      internal static Func<ICluster, ICluster> DefaultClusterboundTransformer = clstr => clstr;
      internal static Func<IRecord, IRecord> DefaultRecordboundTransformer = rec => rec;
      internal static Func<ICluster, bool> DefaultClusterFilterPredicate = clstr => true;
      internal static Func<IRecord, bool> DefaultRecordFilterPredicate = rec => true;
      internal static Func<ICluster, IEnumerable<ICluster>> DefaultUniversalTransformer = clstr => Enumerable.Repeat(clstr, 1);
      internal static Func<ICluster, int> DefaultClusterRouter = clstr => 1;
      internal static Func<IRecord, ICluster, int> DefaultRecordRouter = (rec, clstr) => 1;
      internal static Action<Tuple<ExternalLine, int>, IGlobalCache> DefaultOutputConsumer = (tpl, gc) => { };
      internal static Func<Tuple<ExternalLine, int>, IGlobalCache, Task> DefaultAsyncOutputConsumer = (tpl, gc) => Task.FromResult(0);  //TODO: In .NET 4.6 Task.CompletedTask can be used instead of Task.FromResult(0)
                                                                                                                                        //      (it creates a genuine Task, not a down-casted Task<int>)
      internal static Func<IGlobalCache, string> DefaultOutputInitializer = gc => null;
      internal static Action<IGlobalCache> DefaultOutputDisposer = gc => { };


      /// <summary>
      /// Ctor helper method assign default settings
      /// </summary>
      private void SetInitialValues()
      {
         CloseLoggerOnDispose = true;
         TypeDefiner = DefaultTypeDefiner;
         BufferSize = Constants.Unlimited;
         IntakeRecordLimit = Constants.Unlimited;
         TimeLimit = System.Threading.Timeout.InfiniteTimeSpan;
         InputDataKind = KindOfTextData.Raw;
         IntakeSupplier = DefaultIntakeSupplier;
         AsyncIntakeSupplier = DefaultAsyncIntakeSupplier;
         IntakeInitializer = DefaultIntakeInitializer;
         IntakeDisposer = DefaultIntakeDisposer;
         IntakeBufferFactor = 1.5;
         InputHeadersRepeated = true;
         ActionOnDuplicateKey = ActionOnDuplicateKey.IgnoreItem;
         RecordInitiator = DefaultRecordInitiator;
         ClusterMarker = DefaultClusterMarker;
         MarkerStartsCluster = true;
         InputFieldSeparator = ',';
         DefaultInputFieldWidth = 10;
         DeferTransformation = DeferTransformation.NotDeferred;
         TransformerType = TransformerType.Recordbound;
         ClusterboundTransformer = DefaultClusterboundTransformer;
         RecordboundTransformer = DefaultRecordboundTransformer;
         ClusterFilterPredicate = DefaultClusterFilterPredicate;
         RecordFilterPredicate = DefaultRecordFilterPredicate;
         UniversalTransformer = DefaultUniversalTransformer;
         ConcurrencyLevel = 1;
         TransformBufferFactor = 1.0;
         ClusterSyncInterval = 40;
         DeferOutput = DeferOutput.Auto;
         RouterType = RouterType.SingleTarget;
         ClusterRouter = DefaultClusterRouter;
         RecordRouter = DefaultRecordRouter;
         OutputDataKind = KindOfTextData.Raw;
         OutputConsumer = DefaultOutputConsumer;
         AsyncOutputConsumer = DefaultAsyncOutputConsumer;
         OutputInitializer = DefaultOutputInitializer;
         OutputDisposer = DefaultOutputDisposer;
         OutputBufferFactor = 1.5;
         RepeatOutputHeaders = true;
         OutputFieldSeparator = ',';
         DefaultOutputFieldWidth = 10;
         RepeatLeaders = true;
         RepeatTrailers = true;
      }


#region Environmental settings (read-only)

      //Environmental settings are not settable; instead, they reflect status of Data Conveyer configuration.

      /// <summary>
      /// Name of this configuration in case it was created from a .cfg (and optional .dll) file(s) via RestoreConfig method; otherwise null.
      /// </summary>
      [XmlIgnore]
      public string ConfigName { get; private set; }


      /// <summary>
      /// Information on current version of Data Conveyer.
      /// </summary>
      public ProductInfo DataConveyerInfo
      {
         get { return ProductInfo.CurrentInfo; }
         set { }
      }

#endregion Environmental settings (read-only)


#region General settings

      /// <summary>
      /// <para>
      /// True (default) causes the logger to close (stop logging) when the orchestrator object is disposed.
      /// False keeps the logger open beyond the lifespan of the orchestrator object, which may be helpful in certain troubleshooting scenarios (e.g. to avoid System.ObjectDisposedException: Cannot write to a closed TextWriter when using LogFile logger).
      /// It is recommended that the <see cref="CloseLoggerOnDispose"/> remains at its default value of true, except for troubleshooting scenarios.
      /// </para>
      /// <para>
      /// The <see cref="CloseLoggerOnDispose"/> setting also affects the behavior of the <see cref="SaveConfig(string)"/> method in case an error occurs:
      /// if true, then the error gets logged and the logger is closed (stops logging); if false, then the the error gets logged and the logger remains open.
      /// </para>
      /// </summary>
      public bool CloseLoggerOnDispose { get; set; }


      /// <summary>
      /// <para>
      /// This setting defines data types used in internal representations of record fields.
      /// It contains a set of keys (field names) along with their corresponding data types and optional formats.
      /// </para>
      /// <para>
      /// The setting is in the form of a comma delimited list of items, each item being a pipe delimited triplet: fldName|type|format,
      ///  where type is one of: S=String, M=Decimal, D=DateTime, I=Integer, B=Boolean; and format is the format string used when formatting output.
      /// Format can be omitted with the preceding pipe, in which case no formatting will take place.
      /// Format has no relevance on intake. In addition, with one exception, format is ignored in JSON output, because JSON supports writing elements
      /// in their native data types. The exception is for fields of DateTime type, which are not supported in JSON. DateTime fields are converted to strings
      /// (respecting format) before being submitted to JSON output.
      /// </para>
      /// <para><b>Example:</b><c>"AMOUNT|M,BIRTH_DATE|D|M/d/yyyy,AGE|I"</c></para>
      /// <para>
      /// Sequence of the elements in this setting is irrelevant.
      /// </para>
      /// <para>
      /// Types of the fields not specified in <see cref="ExplicitTypeDefinitions"/> are determined by the <see cref="TypeDefiner"/> function,
      /// which by default assumes string type and no format for all fields.
      /// </para>
      /// <note type="note">
      /// <para>
      /// In case of JSON intake, the elements are parsed according to JSON specifications, which involves automatic data type determination. However,
      /// in order to preserve this type, the corresponding field must be of a matching type. Otherwise, the type conversion will be performed.
      /// </para>
      /// <para>
      /// For example, a JSON element <c>"ID": 5</c> will be parsed as number 5. So, in order to avoid type conversion, a setting of <c>ID|I</c> is needed (otherwise, number 5
      /// will be converted to string "5"). Similarly, an element <c>"ID": "5"</c> will be parsed as string "5". Therefore, no type conversion will take place in absense
      /// of type definition for field "ID" (fields are strings by default); if however setting <c>ID|I</c> is present, then string "5" will be converted
      /// into number 5.
      /// </para>
      /// </note>
      /// </summary>
      public string ExplicitTypeDefinitions { get; set; }


      /// <summary>
      /// A function to determine data types for those fields that are not listed in <see cref="ExplicitTypeDefinitions"/>.
      /// The function takes a field name and returns an ItemDef consisting of a type and format for the field.
      /// Default function assumes every field is of string type and has no format, i.e.:
      /// <code language="c#">fn => new ItemDef(ItemType.String, null)</code>
      /// <code language="vb">Function(fn) New ItemDef(ItemType.[String], Nothing)</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      [XmlIgnore]
      public Func<string, ItemDef> TypeDefiner { get; set; }


      /// <summary>
      /// <para>
      /// A list of definitions of the elements to be held in the global cache (<see cref="IGlobalCache"/>). Global cache is a central repository of arbitrary key value pairs maintained throughout the Data Conveyer process.
      /// Each array element defines a single global cache element. The definition consists of the key optionally followed by a pipe symbol (|) and the initial value to be placed in global cache.
      /// Element keys are of string type (only letters and numbers are recommended). The type of each element depends on the element value: if specified after the pipe symbol, it can be one of: int, DataTime, decimal or string.
      /// In case no pipe symbol is present in element definition, the element will be of type object with a null value. Note that element values (and types as well) can be changed by the <see cref="IGlobalCache.ReplaceValue"/> method.
      /// </para>
      /// <para>Rules for determining the element type depend on the value placed after the pipe symbol (|):</para>
      /// <list type="bullet">
      /// <item>Any unquoted number without decimal point or commas will be of an int type.
      /// Int examples: "Int|0", "Val2|-15".</item>
      /// <item>An unquoted number with decimal point will be of a decimal type.
      /// Decimal examples: "Dec|0.", "AnotherDec|-3.5".</item>
      /// <item>A string in a valid date format will be of a DateTime type.
      /// DateTime examples: "Date|12/31/2012", Val2|12-DEC-12".</item>
      /// <item>Any quoted string or string not fitting other types will be of a string type. Strings can contain any characters including pipe symbols and quotes if quoted, i.e. staring with a quote (ending quote is optional).
      /// String examples (note escaped inner quotes): "Str|abc", "Val2|\"0\"", "Val3|\"0", "Val4|\"\"" (empty string), "Val5|" (empty string)).</item>
      /// <item>In absence of the pipe symbol, a null object is assumed, e.g. "Val1" (null).</item>
      /// </list>
      /// <para>Note that <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/> settings have no meaning in determining the type of the global cache elements.</para>
      /// <para>Also note that this settings only defines the elements of the global cache, and not the signals, which are simply referred to in <see cref="IGlobalCache.RaiseSignal"/>, <see cref="IGlobalCache.AwaitSignal"/>
      /// and <see cref="IGlobalCache.AwaitSignalAsync"/> methods.</para>
      /// </summary>
      public string[] GlobalCacheElements { get; set; }


      /// <summary>
      /// Entities (such as records and/or clusters) that will have property bin objects attached to during Data Conveyer processing.
      /// Default value is <see cref="PropertyBinAttachedTo.Nothing"/>, i.e. no property bins attached.
      /// This feature should be used judiciously due to its impact on performance.
      /// </summary>
      public PropertyBinAttachedTo PropertyBinEntities { get; set; }


      /// <summary>
      /// If true, all initializations are executed regardless if prior initializations failed or not. So, for example <see cref="OutputInitializer"/>  gets executed even after a failure of <see cref="IntakeInitializer"/>.
      /// This may result in unwanted reset of output (such as erasure of prior data) even if the process could not start due to a problem initializing intake.
      /// If false (default), any initialization failure (e.g. in <see cref="IntakeInitializer"/>) will prevent execution of subsequent initializations (such as <see cref="OutputInitializer"/> ).
      /// In this case, troubleshooting of output initialization is only possible after successful intake initialization.
      /// </summary>
      public bool EagerInitialization { get; set; }


      /// <summary>
      /// Capacity of a transformer buffer defined as a maximum number of clusters to be held unprocessed by Data Conveyer.
      /// This setting can be used to control memory consumption of Data Conveyer.
      /// Default value is -1, which means no limit.
      /// </summary>
      public int BufferSize { get; set; }


      /// <summary>
      /// Maximum number of intake records allowed for the process execution. Default value is -1, i.e.:
      /// <code language="c#">Unlimited</code>
      /// <code language="vb">Unlimited</code>
      /// </summary>
      public int IntakeRecordLimit { get; set; }


      /// <summary>
      /// Maximum amount of time allowed for the process execution. Default value is -1 ms, i.e.:
      /// <code language="c#">Timeout.InfiniteTimeSpan</code>
      /// <code language="vb">Timeout.InfiniteTimeSpan</code>
      /// </summary>
      [XmlIgnore]
      public TimeSpan TimeLimit { get; set; }


      /// <summary>
      /// TimeLimit is of TimeSpan type, which is not XML serializable.
      /// So, serialize Ticks (long) instead and use it to instantiate Timespan upon deserialization.
      /// </summary>
      [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DebuggerBrowsable(DebuggerBrowsableState.Never)]
      [XmlElement(DataType = "long", ElementName = "TimeLimit")]
      public long TimeLimit_ticks
      {
         get { return TimeLimit.Ticks; }
         set { TimeLimit = new TimeSpan(value); }
      }


      /// <summary>
      /// True causes Data Conveyer to raise progress events, i.e. PhaseStarted, PhaseFinished and (if ProgressInterval other than 0) ProgressChanged.
      /// If false (default), then no progress events occur.
      /// </summary>
      public bool ReportProgress { get; set; }


      /// <summary>
      /// Frequency of raising the ProgressChanges event:
      /// <list type="bullet">
      ///  <item><term>0</term><description> Never (default)</description></item>
      ///  <item><term>1</term><description> Every cluster</description></item>
      ///  <item><term>2</term><description> Every other cluster</description></item>
      ///  <item><term>...</term><description> Etc.</description></item>
      /// </list>
      /// This setting is ignored if ReportProgree is false.
      /// </summary>
      public int ProgressInterval { get; set; }


      /// <summary>
      /// Handler of the PhaseStarting event. Data Conveyer calls this function at start of a processing phase.
      /// Note that any exceptions thrown by event handlers are discarded by Data Conveyer.
      /// </summary>
      /// 
      [XmlIgnore]
      public EventHandler<PhaseEventArgs> PhaseStartingHandler { get; set; }


      /// <summary>
      /// Handler of the ProgressChanged event. Data Conveyer calls this function at specified intervals during processing.
      /// Note that any exceptions thrown by event handlers are discarded by Data Conveyer.
      /// </summary>
      [XmlIgnore]
      public EventHandler<ProgressEventArgs> ProgressChangedHandler { get; set; }


      /// <summary>
      /// Handler of the PhaseFinished event. Data Conveyer calls this function at the end of a processing phase.
      /// Note that any exceptions thrown by event handlers are discarded by Data Conveyer.
      /// </summary>
      [XmlIgnore]
      public EventHandler<PhaseEventArgs> PhaseFinishedHandler { get; set; }


      /// <summary>
      /// Handler of the ErrorOccurred event. Data Conveyer calls this function (regardless of the <see cref="ReportProgress"/> setting)
      /// when an exception thrown during processing (for example in the caller supplied code) is unhandled. 
      /// This handler is intended for troubleshooting purposes. It occurs immediately before the process completes with the
      /// status of <see cref="CompletionStatus.Failed"/> and provides the last chance to identify the reason of (but not recovery from) the failure. 
      /// Also note that any exceptions thrown by event handlers are discarded by Data Conveyer.
      /// </summary>
      [XmlIgnore]
      public EventHandler<ErrorEventArgs> ErrorOccurredHandler { get; set; }


      /// <summary>
      /// Default value of the segment delimiter - applicable only to X12 data.
      /// On X12 intake, segment delimiter is always determined from ISA segment, so this setting only applies in case ISA segment is absent (incomplete X12 envelope).
      /// On X12 output, in absence of this setting, segment delimiter is determined from intake if also X12 (specifically, from the first ISA segment encountered), or a default value of '~' is assumed.
      /// May contain multiple characters to make output easier to read, such as "~\r\n".
      /// </summary>
      public string DefaultX12SegmentDelimiter { get; set; }


      /// <summary>
      /// Default value of the field delimiter - applicable only to X12 data.
      /// On X12 intake, field delimiter is always determined from ISA segment, so this setting only applies in case ISA segment is absent (incomplete X12 envelope).
      /// On X12 output, in absence of this setting, field delimiter is determined from intake if also X12 (specifically, from the first ISA segment encountered), or a default value of '*' is assumed.
      /// </summary>
      public char DefaultX12FieldDelimiter { get; set; }

#endregion General settings


#region Intake specific settings

      /// <summary>
      /// Type (format) of input data: Raw, Keyword, Delimited, Flat, Arbitrary, XML, JSON or X12.  Default is Raw.
      /// These values are intended for future use: HL7 and Ultimate.
      /// </summary>
      public KindOfTextData InputDataKind { get; set; }


      /// <summary>
      /// <para>
      /// A synonym for the <see cref="InputFileNames"/> setting (to make it more intuitive in case of a single input file).
      /// </para>
      /// <para>
      /// <see cref="InputFileName"/> and <see cref="InputFileNames"/> settings should not be used both at the same time.
      /// </para>
      /// </summary>
      [XmlIgnore]
      public string InputFileName //ignored if IntakeSupplier or IntakeReaders is also defined
      {
         get { return InputFileNames; }
         set { InputFileNames = value; }
      }

      /// <summary>
      /// <para>
      /// Name(s) of (i.e. path(s) to) the input file(s). This setting is the same as (synonym for) the <see cref="InputFileName"/> setting.
      /// If multiple files are specified, the names are separated by pipe symbols(|). Each name can be surrounded by double quotes. The first file is assigned SourceNo=1, the second SourceNo=2, etc.
      /// The files will be read one after another (in SourceNo order) either synchronously or asynchronously, depending on <see cref="AsyncIntake"/> setting.
      /// Ignored if <see cref="TextIntakeSupplier"/> or <see cref="IntakeReaders"/> setting (or one of their equivalent settings) is also submitted.
      /// </para>
      /// <para>
      /// <see cref="InputFileName"/> and <see cref="InputFileNames"/> settings should not be used both at the same time.
      /// </para>
      /// </summary>
      public string InputFileNames { get; set; } //ignored if IntakeSupplier or IntakeReaders is also defined


      /// <summary>
      /// A function returning a text reader object to supply data into the Data Conveyer intake process.
      /// This setting is equivalent to  <see cref="IntakeReaders"/> setting containing a single reader.
      /// <see cref="IntakeReader"/> and <see cref="IntakeReaders"/> settings should not be used both at the same time.
      /// </summary>
      [XmlIgnore]
      public Func<TextReader> IntakeReader
      {
         get { return () =>  IntakeReaders().FirstOrDefault(); }
         set { IntakeReaders = () => Enumerable.Repeat(value(), 1); }
      }


      /// <summary>
      /// A function returning a collection of text reader objects to supply data into the Data Conveyer intake process. Each reader corresponds to a single intake source;
      /// the first reader is assigned SourceNo=1, the second SourceNo=2, etc.
      /// Data will be read from one reader after another, in SourceNo order, either synchronously or asynchronously, depending on <see cref="AsyncIntake"/> setting.
      /// Ignored if the <see cref="TextIntakeSupplier"/> function (or applicable equivalent function) is also submitted.
      /// </summary>
      [XmlIgnore]
      public Func<IEnumerable<TextReader>> IntakeReaders { get; set; }


      /// <summary>
      /// True will cause Data Conveyer to perform intake operations asynchronously (e.g. it will call <see cref="AsyncTextIntakeSupplier"/> or <see cref="AsyncIntakeSupplier"/> function if provided, not the <see cref="TextIntakeSupplier"/> or <see cref="IntakeSupplier"/> function).
      /// False (default) will cause Data Conveyer to perform intake operations synchronously, in which case the <see cref="TextIntakeSupplier"/> or <see cref="IntakeSupplier"/> function is called (if provided).
      /// Note that Data Conveyer performs such synchronous intake on a dedicated thread to prevent a possible deadlock condition.
      /// </summary>
      public bool AsyncIntake { get; set; }


      /// <summary>
      /// A function that supplies a tuple containing a <see cref="ExternalLine"/> object (an input line to be fed into Data Conveyer) and the source number (1-based) (Func&lt;IGlobalCache, Tuple&lt;string,int&gt;&gt;).
      /// Data Conveyer calls this function when <see cref="AsyncIntake"/> is false (providing a single parameter - <see cref="IGlobalCache"/>) in succession until null is received.
      /// When end of data is reached (i.e. all intake sources are depleted), the function must return null (end of data mark), which will initiate processing shutdown with a status of <see cref="CompletionStatus.IntakeDepleted"/>.
      /// Note the difference between null tuples (end of data marks) and tuples containing null <see cref="ExternalLine"/> objects (ignored by Data Conveyer).
      /// Any returned tuples that contain null <see cref="ExternalLine"/> objects are ignored by Data Conveyer; to send an empty line, a tuple containing an empty object (e.g. an empty string) needs to be returned.
      /// If not defined, Data Conveyer assumes default <see cref="IntakeSupplier"/> function that returns no data, but only the end of data mark, i.e.:
      /// <code language="c#">gc => null</code>
      /// <code language="vb">Function(gc) Nothing</code>
      /// This function is called on a dedicated thread to prevent possible deadlocks in situations, such as UI updates made during progress changes.
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the intake supplier is discouraged. It is recommended to instead call the <see cref="SetIntakeSupplier(Func{IGlobalCache, Tuple{ExternalLine, int}})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method that better suit many intake scenarios.
      ///</remarks>
      [XmlIgnore]
      public Func<IGlobalCache, Tuple<ExternalLine, int>> IntakeSupplier { get; set; }


      /// <summary>
      /// A function that supplies contents of a single text line to be fed into Data Conveyer. (Func&lt;string&gt;).
      /// When end of data is reached, the function must return null (end of data mark).
      /// The <see cref="TextIntakeSupplier"/> function is a simplified version of the <see cref="IntakeSupplier"/> function where the following restrictions apply:
      /// <list type="bullet">
      /// <item>Input data kind is textual such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc. (and not for example <see cref="KindOfTextData.XML"/>).</item>
      /// <item>All lines are associated with a single source.</item>
      /// <item>No access to global cache.</item>
      /// </list>
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the intake supplier is discouraged. It is recommended to instead call the <see cref="SetIntakeSupplier(Func{string})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method that better suit many intake scenarios.
      ///</remarks>
      [XmlIgnore]
      public Func<string> TextIntakeSupplier
      {
         //translate between Func<string> and Func<IGlobalCache, Tuple<ExternalLine, int>>
         get { return () => IntakeSupplier(null)?.Item1.Text; }
         set { SetIntakeSupplier(value); }  //i.e.: set { IntakeSupplier = gc => value().ToExternalTuple(); }
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This is the universal overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see>  method.
      /// It may be used in case of any input from multiple sources when access to the global cache is needed.
      /// In most practical scenarios, other overloads are more suitable (easier to implement).
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a tuple containing an ExternalLine object and a source number.</param>
      public void SetIntakeSupplier(Func<IGlobalCache, Tuple<ExternalLine, int>> supplierToSet)
      {
         IntakeSupplier = supplierToSet;
      }

      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of any intake from multiple sources and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a tuple containing an ExternalLine object and a corresponding source number.
      /// The function has no access to global cache.</param>
      public void SetIntakeSupplier(Func<Tuple<ExternalLine, int>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of any intake from a single source when access to the global cache is needed.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns an ExternalLine object.
      /// The function is suitable in case of a single source (the implied source number is 1).</param>
      public void SetIntakeSupplier(Func<IGlobalCache, ExternalLine> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet(gc)?.ToTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of any intake from a single source and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns an ExternalLine object.
      /// The function has no access to global cache and is suitable in case of a single source (the implied source number is 1).</param>
      public void SetIntakeSupplier(Func<ExternalLine> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet()?.ToTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from multiple sources when access to the global cache is needed.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a tuple containing a line of text and the corresponding source number.</param>
      public void SetIntakeSupplier(Func<IGlobalCache, Tuple<string, int>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet(gc)?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from multiple sources and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a tuple containing a line of text and a corresponding source number.
      /// The function has no access to global cache.</param>
      public void SetIntakeSupplier(Func<Tuple<string, int>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet()?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from a single source when access to the global cache is needed.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a string representing a line of text.
      /// The function is suitable in case of a single source (the implied source number is 1).</param>
      public void SetIntakeSupplier(Func<IGlobalCache, string> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet(gc)?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from a single source and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a string representing a line of text.
      /// The function has no access to global cache and is suitable in case of a single source (the implied source number is 1).</param>
      public void SetIntakeSupplier(Func<string> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet()?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of record-centric intake from multiple sources when access to the global cache is needed.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a tuple containing a record (expressed as a sequence of key-value pairs) and the corresponding source number.</param>
      public void SetIntakeSupplier(Func<IGlobalCache, Tuple<IEnumerable<Tuple<string, object>>, int>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet(gc)?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of record-centric intake from multiple sources and no need to access the global cache.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a tuple containing a record (expressed as a sequence of key-value pairs) and a corresponding source number.
      /// The function has no access to global cache.</param>
      public void SetIntakeSupplier(Func<Tuple<IEnumerable<Tuple<string, object>>, int>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet()?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of record-centric intake from a single source when access to the global cache is needed.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a record expressed as a sequence of key-value pairs.
      /// The function is suitable in case of a single source (the implied source number is 1).</param>
      public void SetIntakeSupplier(Func<IGlobalCache, IEnumerable<Tuple<string, object>>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet(gc)?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetIntakeSupplier">SetIntakeSupplier</see> method is intended for use in case of record-centric intake from a single source and no need to access the global cache.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a record expressed as a sequence of key-value pairs.
      /// The function has no access to global cache and is suitable in case of a single source (the implied source number is 1).</param>
      public void SetIntakeSupplier(Func<IEnumerable<Tuple<string, object>>> supplierToSet)
      {
         IntakeSupplier = gc => supplierToSet()?.ToExternalTuple();
      }


      /// <summary>
      /// An asynchronous function that supplies a task with (a promise of) a tuple containing an <see cref="ExternalLine"/> object (an input line to be fed into Data Conveyer) and the source number (1-based) (Func&lt;IGlobalCache, Task&lt;Tuple&lt;string,int&gt;&gt;&gt;).
      /// Data Conveyer calls this function when <see cref="AsyncIntake"/> is true (providing a single parameter - <see cref="IGlobalCache"/>) in succession until null is received.
      /// When end of data is reached (i.e. intake sources are depleted), the function must return a task with null result (end of data mark), which will initiate processing shutdown with a status of <see cref="CompletionStatus.IntakeDepleted"/>.
      /// Note the difference between null tuples (end of data marks) and tuples containing null strings (ignored by Data Conveyer).
      /// Any returned tuples that contain null <see cref="ExternalLine"/> objects are ignored by Data Conveyer; to send an empty line, a tuple containing an empty object (e.g. an empty string) needs to be returned.
      /// If not defined, Data Conveyer assumes default <see cref="AsyncIntakeSupplier"/> function that returns no data, but a task with an end of data result, i.e.:
      /// <code language="c#">gc => Task.FromResult&lt;Tuple&lt;string, int&gt;&gt;(null)</code>
      /// <code language="vb">Function(gc) Task.FromResult(Of Tuple(Of String, Integer))(Nothing)</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the intake supplier is discouraged. It is recommended to instead call the <see cref="SetAsyncIntakeSupplier(Func{IGlobalCache, Task{Tuple{ExternalLine, int}}})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method that better suit many intake scenarios.
      ///</remarks>
      [XmlIgnore]
      public Func<IGlobalCache, Task<Tuple<ExternalLine, int>>> AsyncIntakeSupplier { get; set; }


      /// <summary>
      /// An asynchronous function that supplies a task promising contents of a single text line to be fed into Data Conveyer. (Func&lt;Task&lt;string&gt;&gt;).
      /// When end of data is reached, the function must return null (end of data mark).
      /// The <see cref="AsyncTextIntakeSupplier"/> function is a simplified version of the <see cref="AsyncIntakeSupplier"/> function where the following restrictions apply:
      /// <list type="bullet">
      /// <item>Input data kind is textual such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc. (and not for example <see cref="KindOfTextData.XML"/>).</item>
      /// <item>All lines are associated with a single source.</item>
      /// <item>No access to global cache.</item>
      /// </list>
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the intake supplier is discouraged. It is recommended to instead call the <see cref="SetAsyncIntakeSupplier(Func{Task{string}})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method that better suit many intake scenarios.
      ///</remarks>
      [XmlIgnore]
      public Func<Task<string>> AsyncTextIntakeSupplier
      {
         //translate between Func<Task<string>> and Func<IGlobalCache, Task<Tuple<ExternalLine, int>>>
         get { return async () => { var el = await AsyncIntakeSupplier(null); return el?.Item1.Text; }; }
         set { SetAsyncIntakeSupplier(value); }  //i.e.: set { AsyncIntakeSupplier = async gc => { var s = await value(); return s?.ToExternalTuple(); }; }
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This is the universal overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method.
      /// It may be used in case of any input from multiple sources when access to the global cache is needed.
      /// In most practical scenarios, other overloads are more suitable (easier to implement).
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a task promising a tuple containing an ExternalLine object and a source number.</param>
      public void SetAsyncIntakeSupplier(Func<IGlobalCache, Task<Tuple<ExternalLine, int>>> supplierToSet)
      {
         AsyncIntakeSupplier = supplierToSet;
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of any intake from multiple sources and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a task promising a tuple containing an ExternalLine object and a corresponding source number.
      /// The function has no access to global cache.</param>
      public void SetAsyncIntakeSupplier(Func<Task<Tuple<ExternalLine, int>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => await supplierToSet();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of any intake from a single source when access to the global cache is needed.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a task promising an ExternalLine object.
      /// The function is suitable in case of a single source intake (the implied source number is 1).</param>
      public void SetAsyncIntakeSupplier(Func<IGlobalCache, Task<ExternalLine>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet(gc))?.ToTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of any intake from a single source and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a task promising an ExternalLine object.
      /// The function has no access to global cache and is suitable in case of a single source intake (the implied source number is 1).</param>
      public void SetAsyncIntakeSupplier(Func<Task<ExternalLine>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet())?.ToTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from multiple sources when access to the global cache is needed.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a task promising a tuple containing a line of text and the corresponding source number.</param>
      public void SetAsyncIntakeSupplier(Func<IGlobalCache, Task<Tuple<string, int>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet(gc))?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from multiple sources and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a task promising a tuple containing a line of text and a corresponding source number.
      /// The function has no access to global cache.</param>
      public void SetAsyncIntakeSupplier(Func<Task<Tuple<string, int>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet())?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from a single source when access to the global cache is needed.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a task promising a string representing a line of text.
      /// The function is suitable in case of a single source intake (the implied source number is 1).</param>
      public void SetAsyncIntakeSupplier(Func<IGlobalCache, Task<string>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet(gc))?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of textual intake (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) from a single source and no need to access the global cache.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a task promising a string representing a line of text.
      /// The function has no access to global cache and is suitable in case of a single source intake (the implied source number is 1).</param>
      public void SetAsyncIntakeSupplier(Func<Task<string>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => { var s = await supplierToSet(); return s?.ToExternalTuple(); };
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of record-centric intake from multiple sources when access to the global cache is needed.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a task promising a tuple containing a record (expressed as a sequence of key-value pairs) and the corresponding source number.</param>
      public void SetAsyncIntakeSupplier(Func<IGlobalCache, Task<Tuple<IEnumerable<Tuple<string, object>>, int>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet(gc))?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of record-centric intake from multiple sources and no need to access the global cache.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a task promising a tuple containing a record (expressed as a sequence of key-value pairs) and a corresponding source number.
      /// The function has no access to global cache.</param>
      public void SetAsyncIntakeSupplier(Func<Task<Tuple<IEnumerable<Tuple<string, object>>, int>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => { var tpl = await supplierToSet(); return tpl?.ToExternalTuple(); };
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of record-centric intake from a single source when access to the global cache is needed.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes a single parameter (reference to global cache) and returns a task promising a record expressed as a sequence of key-value pairs.
      /// The function is suitable in case of a single source intake (the implied source number is 1).</param>
      public void SetAsyncIntakeSupplier(Func<IGlobalCache, Task<IEnumerable<Tuple<string, object>>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => (await supplierToSet(gc))?.ToExternalTuple();
      }


      /// <summary>
      /// Designates an asynchronous intake supplier function.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncIntakeSupplier">SetAsyncIntakeSupplier</see> method is intended for use in case of record-centric intake (such as from a single source and no need to access the global cache.
      /// To use this overload, the <see cref="InputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. In either case, data returned by this function is processed the same way.
      /// </summary>
      /// <param name="supplierToSet">A function that takes no parameters and returns a task promising a record expressed as a sequence of key-value pairs.
      /// The function has no access to global cache and is suitable in case of a single source intake (the implied source number is 1).</param>
      public void SetAsyncIntakeSupplier(Func<Task<IEnumerable<Tuple<string, object>>>> supplierToSet)
      {
         AsyncIntakeSupplier = async gc => { var rec = await supplierToSet(); return rec?.ToExternalTuple(); };
      }


      /// <summary>
      /// A function intended to initialize any intake sources (such as open files or database connections) and related resources that may be needed by the <see cref="TextIntakeSupplier"/> or <see cref="AsyncTextIntakeSupplier"/> function.
      /// Data Conveyer calls this function a single time before starting the actual orchestrator processing, such as invocations of <see cref="TextIntakeSupplier"/> function, if one is defined.
      /// However, if <see cref="TextIntakeSupplier"/> or <see cref="AsyncTextIntakeSupplier"/> function is not defined; then this function is not called.
      /// The <see cref="IntakeInitializer"/> function accepts a single parameter (<see cref="IGlobalCache"/>) and returns a string (Func&lt;IGlobalCache, string&gt;).
      /// Null returned value means successful initialization; otherwise, an error message indicating reason for the failure is expected to be returned (Data Conveyer will log this message).
      /// In case of failure, the processing will end in the <see cref="CompletionStatus.InitializationError"/> status.
      /// If not defined, default <see cref="IntakeInitializer"/> simply returns null, i.e.:
      /// <code language="c#">gc => null</code>
      /// <code language="vb">Function(gc) Nothing</code>
      /// </summary>
      [XmlIgnore]
      public Func<IGlobalCache, string> IntakeInitializer { get; set; }



      /// <summary>
      /// An action intended to dispose any intake sources and related resources that were opened by the <see cref="IntakeInitializer"/> function.
      /// Data Conveyer calls this action a single time after completing orchestrator processing (when the orchestrator is disposed).
      /// However, if <see cref="TextIntakeSupplier"/> or <see cref="AsyncTextIntakeSupplier"/> function is not defined; then this action is not called.
      /// The <see cref="IntakeDisposer"/> action accepts a single parameter (<see cref="IGlobalCache"/>) and returns void (Action&lt;IGlobalCache&gt;).
      /// If not defined, Data Conveyer assumes empty action, i.e.:
      /// <code language="c#">gc => { }</code>
      /// <code language="vb">
      /// Sub(gc)
      /// End Sub
      /// </code>
      /// Any exception thrown by this action will be logged, but otherwise ignored.
      /// </summary>
      [XmlIgnore]
      public Action<IGlobalCache> IntakeDisposer { get; set; }


      /// <summary>
      /// Ratio between sizes of the intake buffer and the transformer's input buffer (the latter is defined by the <see cref="BufferSize"/> setting).
      /// This advanced setting allows fine-tuning of memory consumption by Data Conveyer.
      /// For example, if an average cluster on intake is expected to be created from 4 intake records, then it may be sensible to set intake buffer size to 400 records
      ///  and transformer's input buffer size to 100 clusters.  In this case, <see cref="BufferSize"/> = 100 and <see cref="IntakeBufferFactor"/> = 4.0.
      /// Default value for <see cref="IntakeBufferFactor"/> is 1.5.
      /// This setting is respected only if <see cref="BufferSize"/> is set to a positive value (i.e. ignored in case of <see cref="BufferSize"/>'s default value of -1 (Unlimited)).
      /// </summary>
      public double IntakeBufferFactor { get; set; }


      /// <summary>
      /// True means 1st input line contains field names and data starts from the 2nd line; false (default) means data starts from the 1st line (default field names are assigned in this case).
      /// This setting applies only to data kinds that support header rows, such as <see cref="KindOfTextData.Delimited"/> or <see cref="KindOfTextData.Flat"/>; otherwise, it is  ignored, in which case data always starts from the 1st line.
      /// </summary>
      public bool HeadersInFirstInputRow { get; set; }


      /// <summary>
      /// Relevant only if multiple intake sources are present and <see cref="HeadersInFirstInputRow"/> is true.
      /// True (default) means that all intake sources contain the header row; in this case Data Conveyer will read the headers from the first source that supplied intake data and will ignore the header rows from the remaining sources.
      /// False means that only the source that supplies the intake data first contains the header row (typically the source with SourceNo=1, but it can actually be any source); the remaining sources are assumed to only contain data rows (regardless of the <see cref="HeadersInFirstInputRow"/> setting).
      /// In either case, the only header row actually considered is the one from the source that supplies intake first. Note that all intake sources are subjected to the same set of processing rules, which implies that the same header row is applicable to all sources (hence the header row should be identical for all sources).
      /// </summary>
      public bool InputHeadersRepeated { get; set; }


      /// <summary>
      /// True will keep double quotes surrounding values if any; false (default) will strip surrounding quotes.
      /// Note that quotes are stripped before possible trimming; so unless quote is the very 1st character, quotes will be retained regardless of this setting.
      /// </summary>
      public bool RetainQuotes { get; set; }


      /// <summary>
      /// True means leading and trailing spaces will be trimmed from values encountered during intake; default is false meaning all spaces are preserved.
      /// Note that <see cref="RetainQuotes"/> = true will prevent trimming of quoted values.
      /// </summary>
      public bool TrimInputValues { get; set; }


      /// <summary>
      /// Prefix to be trimmed (removed) from every key on input, if any (e.g. @p).
      /// Default value is null (no prefix to be removed).
      /// </summary>
      public string InputKeyPrefix { get; set; } //this prefix value will be trimmed from keys


      /// <summary>
      /// True will cause exclusion of items (fields) with keys not matching the <see cref="InputKeyPrefix"/>; false (default) will include such fields (with keys in their entirety).
      /// Use caution when assigning true to this setting, as it may result in records with no contents (when none of the fields match prefix specified in <see cref="InputKeyPrefix"/> setting).
      /// </summary>
      public bool ExcludeItemsMissingPrefix { get; set; } //if true, items with mismatched keys will be excluded


      /// <summary>
      /// Action to take in case the key is repeated on a single record: IgnoreItem, ExcludeRecord or AssignDefaultKey. Default action is IgnoreItem.
      /// </summary>
      public ActionOnDuplicateKey ActionOnDuplicateKey { get; set; }


      /// <summary>
      /// <para>Introduces records into the processing pipeline of Data Conveyer.</para>
      /// <para>
      /// This function is called once per record immediately after the record is read from intake and parsed, before being forwarded to the clustering process.
      /// There are 2 roles of this function: trace bin setup and trigger the start of the <see cref="Phase.Transformation"/> phase.
      /// Any data collected from the current record can be stored in a trace bin for access during processing of subsequent records (as well as during subsequent phases of processing).
      /// The start of the <see cref="Phase.Transformation"/> phase can be triggered by this function only in case of <see cref="DeferTransformation"/> set to <see cref="DeferTransformation.UntilRecordInitiation"/>.
      /// </para>
      /// <para>The function accepts 2 parameters: current record and a trace bin object (dictionary).
      /// The function returns boolean value to trigger the start of the <see cref="Phase.Transformation"/> phase in case of <see cref="DeferTransformation"/> set to <see cref="DeferTransformation.UntilRecordInitiation"/>.
      /// Note that records are processed sequentially on <see cref="Phase.Intake"/>; after returning the first true (or if <see cref="DeferTransformation"/> setting is other than <see cref="DeferTransformation.UntilRecordInitiation"/>),
      /// the values returned by this function are inconsequential.
      /// In case <see cref="RecordInitiator"/> returns false for all records and the <see cref="DeferTransformation"/> is <see cref="DeferTransformation.UntilRecordInitiation"/>, the transformation starts after all input records have been read.</para>
      /// <para>Deferral of <see cref="Phase.Transformation"/> may be useful in cases where transformation of initial clusters (e.g. head cluster) requires data that is read from some records during <see cref="Phase.Intake"/> and saved in global cache.
      /// Note though that such deferral affects performance as well as memory footprint; and in case of limited buffer sizes may lead to deadlocks.</para> 
      /// If not supplied, Data Conveyer assumes default function that does not make any updates and returns true, i.e.:
      /// <code language="c#">(rec, tb) => true</code>
      /// <code language="vb">Function(rec, tb) True</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      [XmlIgnore]
      public Func<IRecord, IDictionary<string, object>, bool> RecordInitiator { get; set; }


      /// <summary>
      /// A predicate (boolean function) to identify records that cause cluster splits (either starting a new cluster or ending a cluster depending on the <see cref="MarkerStartsCluster"/> setting).
      /// It accepts 3 parameters: the current record, the previous record and the counter of records accumulated so far in the current cluster. Note that the previous record is null for the first record.
      /// If the predicate returns true, it causes cluster split (before or after the current record depending on <see cref="MarkerStartsCluster"/> value);
      /// returning false causes continuation of record accumulation into the current cluster.
      /// In case this function marks the first record of a cluster (i.e. <see cref="MarkerStartsCluster"/> is true), then the current record starts a new set of records accumulated for a cluster;
      /// otherwise (<see cref="MarkerStartsCluster"/> is false, i.e. the function marks the last record of a cluster), the current record ends the set of records accumulated for a cluster, and a new empty
      /// set of accumulated records is created.
      /// If not specified, the default function will split clusters on every record, i.e.:
      /// <code language="c#">(r, pr, i) => true</code>
      /// <code language="vb">Function(r, pr, i) True</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      [XmlIgnore]
      public Func<IRecord, IRecord, int, bool> ClusterMarker { get; set; }


      /// <summary>
      /// True (default) means that <see cref="ClusterMarker"/> predicate matches the first record of a cluster (i.e. starts a cluster); false means that predicate matches the last record of a cluster (i.e. ends a cluster).
      /// As a general rule, true value is recommended (marker starts a cluster), especially in cases where <see cref="ClusterMarker"/> predicate relies on the previous record contents or the number of records accumulated so far;
      /// false value (marker ends a cluster) should only be used in cases where <see cref="ClusterMarker"/> predicate relies solely on the current record contents.
      /// </summary>
      public bool MarkerStartsCluster { get; set; } //true = predicate matches first cluster record; false = predicate matches last cluster record


      /// <summary>
      /// <para>
      /// Comma delimited list of fields as they appear on intake lines.
      /// Each field is defined by a name and width, separated by a pipe (|) symbol.
      /// Field widths are only applicable to <see cref="KindOfTextData.Flat"/> (fixed width) data; they are ignored for other kinds of input data.  Where omitted or invalid, a default width (<see cref="DefaultInputFieldWidth"/>) is assumed.
      /// Field names specified in this setting take precedence over those in the first row headers (<see cref="KindOfTextData.Delimited"/> and <see cref="KindOfTextData.Flat"/> data), so in case of <see cref="HeadersInFirstInputRow"/>=true,
      /// the 1st row data may get discarded.
      /// </para>
      /// <para>
      /// If a field name is omitted, a default name will be used (either from the header row or from a formula, which yields Fldnnn, where nnn is the field sequence number; exception is <see cref="KindOfTextData.X12"/> data, where fields are named Segment, Elem001, Elem002, ...).
      /// This setting, when accompanied by <see cref="AllowOnTheFlyInputFields"/> of false, can be used to only accept those fields specified and exclude all other fields from intake (e.g. in case of <see cref="KindOfTextData.Keyword"/> data).
      /// </para>
      /// <para>Examples:</para>
      /// <list type="bullet">
      /// <listheader>Examples:</listheader>
      /// <item><term>|10,|4,|12</term><description> (flat data, records 26 character long, field names in header row or default names)</description></item>
      /// <item><term>Seq#|5, First Name|12,Mid Init|1, Last Name or Company|20, Zip Code|5</term><description> (flat data, records 43 character long)</description></item>
      /// <item><term>Seq#,Name,Description</term><description> (keyword data, exclude all fields from intake except for the 3 specified)</description></item>
      /// </list>
      /// </summary>
      public string InputFields { get; set; }


      /// <summary>
      /// Character that separates fields on intake lines. Only applicable to Delimited and Keyword data, ignored in case of other data kinds.
      /// If not specified, a comma is assumed.
      /// </summary>
      public char InputFieldSeparator { get; set; }

      internal Tuple<string, string>[] ArbitraryInputDefsBackingField;  //Item1=field name; Item2=regex

      /// <summary>
      /// Array of elements that define fields to be extracted from input lines.
      /// Each element is a string consisting of 2 parts separated by a space: a field name followed by a regular expression containing formula to extract a value from input line.
      /// Data Conveyer will extract the fields in the order they are specified in this setting.
      /// This setting is mandatory for <see cref="InputDataKind"/> of Arbitrary; if specified for other data kinds, it is ignored.
      /// </summary>
      public string[] ArbitraryInputDefs
      {
         //Unlike other properties, this one has a backing field of a different type, i.e. Tuple<string,string>[] (where field name and the reqex are separated into the 2 element tuple)
         get { return ArbitraryInputDefsBackingField?.Select(t => t.Item1 + " " + t.Item2).ToArray(); }
         set
         {
            ArbitraryInputDefsBackingField = value?.Select(s =>
            {
               var x = s.IndexOf(' '); return Tuple.Create(s.Substring(0, x), s.Substring(x + 1));
            }).ToArray();
         }
      }


      /// <summary>
      /// Default width of fields in flat input data; applicable only if <see cref="InputDataKind"/> is Flat, ignored otherwise.
      /// If not specified, a default width of 10 is assumed.
      /// </summary>
      public int DefaultInputFieldWidth { get; set; }


      /// <summary>
      /// False (default) means no new fields beyond those defined in <see cref="InputFields"/> (or 1st row if applicable) are allowed.  Any additional fields encountered during intake processing will be excluded.
      /// True means that new fields can be added on the fly in subsequent data records; their names and types are determined according to standard rules.
      /// In case of Keyword data, default setting (false) requires all fields (keys) to be listed in the <see cref="InputFields"/> setting (keys not listed there will be excluded, so in absence of <see cref="InputFields"/> no fields will be present).
      /// True setting allows inclusion of all fields for Keyword data.
      /// This setting is ignored in case of the following data kinds on intake:
      /// <list type="bullet">
      ///  <item><term>Flat</term><description>Flat data fields are determined up-front from either <see cref="InputFields"/> setting or the first row.</description></item>
      ///  <item><term>Arbitrary</term><description>Arbitrary data can only be determined from the <see cref="ArbitraryInputDefs"/> setting.</description></item>
      ///  <item><term>X12</term><description>In case of X12 data, fields are added dynamically from X12 segments, so that this setting is assumed to be true.</description></item>
      /// </list>
      /// </summary>
      public bool AllowOnTheFlyInputFields { get; set; }


      /// <summary>
      /// True causes Data Conveyer to add an extra empty cluster (so called head cluster) before the first cluster formed from intake records.
      /// False (default) means no foot cluster will be added at the end of intake.
      /// The head cluster always has a <see cref="ICluster.StartRecNo"/> of 0 (<see cref="Constants.HeadClusterRecNo"/>) and <see cref="ICluster.StartSourceNo"/> of 1. Header and/or leader contents, if present, will precede the head cluster on output.
      /// </summary>
      public bool PrependHeadCluster { get; set; }


      /// <summary>
      /// True causes Data Conveyer to add an extra empty cluster (so called foot cluster) after the last cluster formed from intake records.
      /// False (default) means no foot cluster will be added at the end of intake.
      /// The foot cluster always has a <see cref="ICluster.StartRecNo"/> of -1 (<see cref="Constants.FootClusterRecNo"/>) and <see cref="ICluster.StartSourceNo"/> of 1. If trailer contents is present, it will follow the foot cluster on output.
      /// </summary>
      public bool AppendFootCluster { get; set; }


      /// <summary>
      /// A string containing comma-separated paraketers for parsing <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/> data on intake.
      /// Each such parameter is a key-value pair with a pipe symbol (|) separating the key and the value.
      /// The parameters reflect the shape of data to parse and define the elements to be extracted.
      /// There are some differences (explained below) in their interpretation in case of <see cref="KindOfTextData.XML"/> vs <see cref="KindOfTextData.JSON"/>.
      /// The following keys can be used:
      /// <list type="bullet">
      ///   <item>
      ///     <term>CollectionNode</term>
      ///     <description>
      ///       "xpath" to the collection of clusters (or records if the ClusterNode parameter is absent).
      ///       If this parameter is absent for <see cref="KindOfTextData.XML"/>, then intake is expected to contain XML fragment where each root constitutes a record or a cluster.
      ///       In case of <see cref="KindOfTextData.JSON"/>, absent or empty value generally means an array instead of an object.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>ClusterNode</term>
      ///     <description>
      ///       "xpath" to the cluster node within the collection node. Records within a cluster node will be assigned the same cluster number (sequential).
      ///       If this parameter is absent, then all records will be assigned a cluster number of 0 (undetermined) and the clusters will
      ///       be determined solely by the <see cref="ClusterMarker"/> function.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>RecordNode</term>
      ///     <description>
      ///       "xpath" to the record node within the cluster node (or the collection node if the cluster node is empty).
      ///       The RecordNode parameter cannot be absent, although in case of <see cref="KindOfTextData.JSON"/>, it can be empty.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>IncludeExplicitText</term>
      ///     <description>
      ///       <see cref="KindOfTextData.XML"/> only, ignored in case of <see cref="KindOfTextData.JSON"/>. true to include explicit text inside record nodes in XML data; false (default) to ignore explicit text.
      ///       Explicit text is the text contained directly inside an XML element that represents the record node; this is not typically expected.
      ///       Data Conveyer assigns a special key of "__explicitText__" to explicit text in the record node.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>IncludeAttributes</term>
      ///     <description>
      ///       <see cref="KindOfTextData.XML"/> only, ignored in case of <see cref="KindOfTextData.JSON"/>. true to include attributes (the key of the corresponding item will be prefixed by @); truePlain to include attributes (without prefix in item key); false (default) to ignore explicit text.
      ///       It is generally recommended that the keys (names) of items that originate from XML attributes be prepended with @; therefore setting of true is preferred over truePlain.
      ///       In the latter case, name conflicts are possible between items originating from attributes and inner nodes. 
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>AddClusterDataToTraceBin</term>
      ///     <description>
      ///       <see cref="KindOfTextData.XML"/> only, ignored in case of <see cref="KindOfTextData.JSON"/>. Also ignored if ClusterNode value is absent.
      ///       true to include attributes of the cluster node(s) as key value pairs in the trace bins attached to the records of the cluster.
      ///       false to exclude cluster data from intake processing.
      ///       The keys of the elements placed in the trace bin reflect nodes traversed to reach the cluster node (including the attribute node itself)
      ///       separated by periods. For example, if ClusterNode value is Region/State and the actual nodes contain &lt;Region name="East"&gt;&lt;State abbrev="NJ"&gt;...,
      ///       then there will be 2 elements placed in the trace bin with keys of Region.name and Region.State.abbrev and the corresponding values of East and NJ.
      ///     </description>
      ///   </item>
      /// </list>
      /// <note type="note">
      /// <para>
      /// "xpath" in any of the node parameters is a simplified version of the xpath syntax.
      /// It is always relative to the containing node (no need for ./).
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, it contains names of nodes (nested in the node hierarchy) separated by /.
      /// Empty nodes are allowed, in which case the intake is expected to contain an array at a given hierarchy level.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, each node can contain attributes. For example, "xpath" of "Department[@name=\"QA\"]/Employees" can be used to identify employees of the QA department.
      /// Empty nodes are not allowed and the // syntax is not supported.
      /// </para>
      /// </note>
      /// <para><b>Example 1:</b><c>"CollectionNode|Members,RecordNode|Member"</c><i>(<see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>)</i></para>
      /// <para><b>Example 2:</b><c>"CollectionNode|Root/Members,ClusterNode|Group/FamilyRecordNode|Member"</c><i>(<see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>)</i></para>
      /// <para><b>Example 3:</b><c>"RecordNode|row"</c><i>(XML fragment or <see cref="KindOfTextData.JSON"/> object with an array)</i></para>
      /// <para><b>Example 4:</b><c>"CollectionNode|,RecordNode|"</c><i>(<see cref="KindOfTextData.JSON"/> only - an array of objects=records)</i></para>
      /// <para><b>Example 5:</b><c>"ClusterNode|,RecordNode|"</c><i>(<see cref="KindOfTextData.JSON"/> only - an array of arrays=clusters of objects=records)</i></para>
      /// <para><b>Example 6:</b><c>"RecordNode|"</c><i>(<see cref="KindOfTextData.JSON"/> only - multiple objects containing records)</i></para>
      /// <para><b>Example 7:</b><c>"CollectionNode|Root/Members[@region=\"North\"],ClusterNode|Group[@id=2][@zone=\"\"]/Family,RecordNode|Data/Member[@class],IncludeExplicitText|true"</c><i>(<see cref="KindOfTextData.XML"/> only)</i></para>
      /// <para>This configuration setting is only applicable when <see cref="InputDataKind"/> value is <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>.</para>
      /// </summary>
      public string XmlJsonIntakeSettings { get; set; }

#endregion Intake specific settings


#region Transform specific settings

      /// <summary>
      /// Defines when Data Conveyer is allowed to start the <see cref="Phase.Transformation"/> phase. One of:
      /// <list type="bullet">
      /// <item><see cref="DeferTransformation.NotDeferred"/> - (default) appropriate in most scenarios.</item>
      /// <item><see cref="DeferTransformation.UntilRecordInitiation"/> - typically used in conjunction with the <see cref="RecordInitiator"/> function.</item>
      /// <item><see cref="DeferTransformation.UntilIntakeCompletion"/> - not recommended, except for troubleshooting.</item>
      /// <item><see cref="DeferTransformation.Indefinitely"/> - restricted for use in specialized tests only!</item>
      /// </list>
      /// Note that after all records are read, the Intake phase still continues execution by executing record clustering. However, during the clustering process Data Conveyer has
      /// no ability to trigger the start of the Transformation phase. Similarly, the <see cref="ClusterMarker"/> function (unlike the <see cref="RecordInitiator"/> function ) has no ability 
      /// to set the trace bin contents.
      /// </summary>
      public DeferTransformation DeferTransformation { get; set; }


      /// <summary>
      /// Type of the transformer: Clusterbound, Recordbound, ClusterFilter, RecordFilter or Universal.  Default transformer type is Recordbound.
      /// The Aggregator type is designated for future use.
      /// </summary>
      public TransformerType TransformerType { get; set; }


      /// <summary>
      /// A function that takes a single cluster and returns a single cluster; specific to <see cref="TransformerType.Clusterbound"/> transformer type.
      /// In case the function returns null (Nothing in Visual Basic), the cluster will be filtered out.
      /// This makes the <see cref="TransformerType.ClusterFilter"> and </see> <see cref="ClusterFilterPredicate"/> a special case of 
      /// <see cref="TransformerType.Clusterbound"> and </see> <see cref="ClusterboundTransformer"/> where unfiltered clusters are passed through.
      /// If not supplied, a default pass-through function is used that passes input cluster to output, i.e.:
      ///  <code language="c#">clstr => clstr</code>
      ///  <code language="vb">Function(clstr) clstr</code>
      ///  Any exception thrown by this function will cause the process shutdown (CompletionStatus of Failed).
      /// </summary>
      [XmlIgnore]
      public Func<ICluster, ICluster> ClusterboundTransformer { get; set; }


      /// <summary>
      /// A function that takes a single record and returns a single record; specific to <see cref="TransformerType.Recordbound"/> transformer type.
      /// In case the function returns null (Nothing in Visual Basic), the record will be filtered out.
      /// This makes the <see cref="TransformerType.RecordFilter"> and </see> <see cref="RecordFilterPredicate"/> a special case of 
      /// <see cref="TransformerType.Recordbound"> and </see> <see cref="RecordboundTransformer"/> where unfiltered records are passed through.
      /// If not supplied, a default pass-through function is used that passes input record to output, i.e.:
      /// <code language="c#">rec => rec</code>
      /// <code language="vb">Function(rec) rec</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      [XmlIgnore]
      public Func<IRecord, IRecord> RecordboundTransformer { get; set; }


      /// <summary>
      /// A predicate (boolean function) that takes a single cluster and returns true to accept the cluster or false to reject it; specific to <see cref="TransformerType.ClusterFilter"/> transformer type.
      /// If not supplied, a default pass-through predicate is used that always returns true, i.e.:
      ///  <code language="c#">clstr => true</code>
      ///  <code language="vb">Function(clstr) True</code>
      ///  Any exception thrown by this function will cause the process shutdown (CompletionStatus of Failed).
      /// </summary>
      [XmlIgnore]
      public Func<ICluster, bool> ClusterFilterPredicate { get; set; }


      /// <summary>
      /// A predicate (boolean function) that takes a single record and returns true to accept the record or false to reject it; specific to <see cref="TransformerType.RecordFilter"/> transformer type.
      /// Note that in case all records for a cluster are rejected, then the cluster will be rejected.
      /// If not supplied, a default pass-through predicate is used that always returns true, i.e.:
      ///  <code language="c#">rec => true</code>
      ///  <code language="vb">Function(rec) True</code>
      ///  Any exception thrown by this function will cause the process shutdown (CompletionStatus of Failed).
      /// </summary>
      [XmlIgnore]
      public Func<IRecord, bool> RecordFilterPredicate { get; set; }


      /// <summary>
      ///  A function that  takes a single cluster and returns a sequence of clusters; specific to <see cref="TransformerType.Universal"/> transformer type.
      ///  If not supplied, a default pass-through function is used that passes input cluster to output as a single element enumerable, i.e.:
      ///  <code language="c#">clstr => Enumerable.Repeat(clstr, 1)</code>
      ///  <code language="vb">Function(clstr) Enumerable.Repeat(clstr, 1)</code>
      ///  Any exception thrown by this function will cause the process shutdown (CompletionStatus of Failed).
      /// </summary>
      [XmlIgnore]
      public Func<ICluster, IEnumerable<ICluster>> UniversalTransformer { get; set; }


      /// <summary>
      /// Degree of parallelism during transformation phase; defined as a maximum number of engines performing transformation.
      /// If not supplied, a default value of 1 is used.
      /// </summary>
      public int ConcurrencyLevel { get; set; }


      /// <summary>
      /// Ratio between sizes of the transformer's output and input buffers (transformer's input buffer size is defined by the <see cref="BufferSize"/> setting).
      /// This advanced setting allows fine-tuning of memory consumption by Data Conveyer.
      /// For example, if transformation process is expected to remove (filter out) on average every other cluster, then it may be sensible to set transformer's input buffer size to 100 clusters
      ///  and the transformer's output buffer size to 50 clusters.  In this case, <see cref="BufferSize"/> = 100 and <see cref="TransformBufferFactor"/> = 0.5.
      /// Default value for <see cref="IntakeBufferFactor"/> is 1.0.
      /// This setting is respected only if <see cref="BufferSize"/> is set to a positive value (i.e. ignored in case of <see cref="BufferSize"/>'s default value of -1 (Unlimited)).
      /// </summary>
      public double TransformBufferFactor { get; set; }


      /// <summary>
      /// If true, fields (items) can be added to and removed from records during transformations.
      /// If false (default), no fields can be added/removed during transformations (although field values can still be update and records/clusters can be cloned).
      /// </summary>
      public bool AllowTransformToAlterFields { get; set; }


      /// <summary>
      /// This advanced setting specifies number of milliseconds DataConveyer awaits when synchronizing processing of head and foot clusters.
      /// Note that regardless of <see cref="ConcurrencyLevel"/> setting, DataConveyer guarantees that the head cluster (if present) will be processed before
      /// all other clusters and that the foot cluster (if present) will be processed after all other clusters. The order of processing remaining ("regular")
      /// clusters is not guaranteed. The default setting of 40 ms is suitable for most scenarios.
      /// </summary>
      public int ClusterSyncInterval { get; set; }

#endregion Transform specific settings


#region Output specific settings

      /// <summary>
      /// Defines when Data Conveyer is allowed to start the <see cref="Phase.Transformation"/> phase.
      /// This setting should be left at its default value of <see cref="DeferOutput.Auto"/>.
      /// The value of <see cref="DeferOutput.Indefinitely"/> is restricted for use in specialized tests only!
      /// </summary>
      public DeferOutput DeferOutput { get; set; }


      /// <summary>
      /// Type of router that determines the output target. One of: SingleTarget (default), SourceToTarget, PerCluster or PerRecord.
      /// </summary>
      public RouterType RouterType { get; set; }


      /// <summary>
      /// A function to determine the output target for every record in a given cluster.  It receives an output cluster and returns TargetNo to be assigned to every record of the cluster (Func&lt;ICluster, int&gt;).
      /// This function is specific to <see cref="RouterType.PerCluster"/> router type; it is ignored for other router types.  If not supplied, a default function that returns 1 for every cluster is assumed, i.e.:
      /// <code language="c#">clstr => 1</code>
      /// <code language="vb">Function(clstr) 1</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      [XmlIgnore]
      public Func<ICluster, int> ClusterRouter { get; set; }


      /// <summary>
      /// A function to determine the output target for a given record. It receives an output record and a cluster that contains the record and returns TargetNo to be assigned to the record (Func&lt;IRecord, ICluster, int&gt;).
      /// This function is specific to <see cref="RouterType.PerRecord"/> router type; it is ignored for other router types.  If not supplied, a default function that returns 1 for every record is assumed, i.e.:
      /// <code language="c#">(rec, clstr) => 1</code>
      /// <code language="vb">Function(rec, clstr) 1</code>
      /// Any exception thrown by this function will cause the process shutdown with a completion status of <see cref="CompletionStatus.Failed"/>.
      /// </summary>
      [XmlIgnore]
      public Func<IRecord, ICluster, int> RecordRouter { get; set; }


      /// <summary>
      /// Type (format) of output data: Raw, Keyword, Delimited, Flat, Arbitrary, X12, XML or JSON.  Default is Raw.
      /// HL7 and Ultimate types are designated for future use.
      /// </summary>
      public KindOfTextData OutputDataKind { get; set; }


      /// <summary>
      /// <para>
      /// A synonym for the <see cref="OutputFileNames"/> setting (to make it more intuitive in case of a single output file).
      /// </para>
      /// <para>
      /// <see cref="OutputFileName"/> and <see cref="OutputFileNames"/> settings should not be used both at the same time.
      /// </para>      /// </summary>
      [XmlIgnore]
      public string OutputFileName
      {
         get { return OutputFileNames; }
         set { OutputFileNames = value; }
      }


      /// <summary>
      /// <para>
      /// Name(s) of (path(s) to) the output file(s). This setting is the same as (synonym for) the <see cref="OutputFileName"/> setting.
      /// </para>
      /// <para>
      /// If multiple files are specified, the names are separated by pipe symbols(|). Each name can be surrounded by double quotes. The first file is assigned TargetNo=1, the second TargetNo=2, etc.
      /// Number of files specified here must be equal the highest TargetNo returned by the <see cref="ClusterRouter"/> function.
      /// Ignored if <see cref="TextOutputConsumer"/> or <see cref="OutputWriters"/> setting (or one of their equivalent settings) is also submitted.
      /// </para>
      /// <para>
      /// <see cref="OutputFileName"/> and <see cref="OutputFileNames"/> settings should not be used both at the same time.
      /// </para>
      /// </summary>
      public string OutputFileNames { get; set; }


      /// <summary>
      /// A function returning a text writer object to consume data produced by the Data Conveyer output.
      /// This setting is equivalent to  <see cref="OutputWriters"/> setting containing a single writer.
      /// <see cref="OutputWriter"/> and <see cref="OutputWriters"/> settings should not be used both at the same time.
      /// </summary>
      [XmlIgnore]
      public Func<TextWriter> OutputWriter
      {
         get { return () => OutputWriters().FirstOrDefault(); }
         set { OutputWriters = () => Enumerable.Repeat(value(), 1); }
      }


      /// <summary>
      /// A function returning a collection of text writer objects to consume data produced by the Data Conveyer output. Each writer corresponds to a single output target;
      /// the first writer is assigned TargetNo=1, the second TargetNo=2, etc.
      /// Number of files specified here must be equal the highest TargetNo returned by the <see cref="ClusterRouter"/> function.
      /// Ignored if the <see cref="TextOutputConsumer"/> function (or applicable equivalent function) is also submitted.
      /// </summary>
      [XmlIgnore]
      public Func<IEnumerable<TextWriter>> OutputWriters { get; set; }


      /// <summary>
      /// True will cause Data Conveyer to perform output operations asynchronously (i.e. it will call <see cref="AsyncTextOutputConsumer"/> or <see cref="AsyncOutputConsumer"/> function if provided, not the <see cref="TextOutputConsumer"/> or <see cref="OutputConsumer"/> function).
      /// False (default) to perform intake operations synchronously, in which case the <see cref="TextOutputConsumer"/> or <see cref="OutputConsumer"/> function is called (if provided).
      /// </summary>
      public bool AsyncOutput { get; set; }


      /// <summary>
      /// An action (void function) that consumes a tuple containing a <see cref="ExternalLine"/> object (a single output line received from Data Conveyer) and the target number (1-based). (Action&lt;Tuple&lt;string, int&gt;&gt;).
      /// Reference to global cache (<see cref="IGlobalCache"/> is passed as the second parameter.
      /// Data Conveyer calls this action (when <see cref="AsyncOutput"/> is false) in succession passing (tuples with) the output lines one at a time.
      /// The last tuple sent by Data Conveyer is always null (end of data mark).
      /// If not defined, Data Conveyer assumes default <see cref="OutputConsumer"/> action that ignores data passed to it, i.e.:
      /// <code language="c#">(tpl, gc) => { }</code>
      /// <code language="vb">
      /// Sub(tpl, gc)
      /// End Sub
      /// </code>
      /// Any exception thrown by this action will cause the process shutdown with a <see cref="CompletionStatus"/> of Failed.
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the output consumer is discouraged. It is recommended to instead call the <see cref="SetOutputConsumer(Action{Tuple{ExternalLine, int}, IGlobalCache})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method that better suit many output scenarios.
      ///</remarks>
      [XmlIgnore]
      public Action<Tuple<ExternalLine, int>, IGlobalCache> OutputConsumer { get; set; }


      /// <summary>
      /// An action (void function) that consumes a single line of text received from Data Conveyer. (Action&lt;string&gt;).
      /// The last line sent by Data Conveyer is always null (end of data mark).
      /// The <see cref="TextOutputConsumer"/> action is a simplified version of the <see cref="OutputConsumer"/> action where the following restrictions apply:
      /// <list type="bullet">
      /// <item>Output data kind is textual such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc. (and not for example <see cref="KindOfTextData.XML"/>).</item>
      /// <item>All lines are sent to a single target (regardless of the target determined by the <see cref="ClusterRouter"/> function).</item>
      /// <item>No access to global cache.</item>
      /// </list>
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the output consumer is discouraged. It is recommended to instead call the <see cref="SetOutputConsumer(Action{string})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method that better suit many output scenarios.
      ///</remarks>
      [XmlIgnore]
      public Action<string> TextOutputConsumer
      {
         //translate between Action<string> and Action<Tuple<ExternalLine, int>, IGlobalCache>
         get { return s => OutputConsumer(s?.ToExternalTuple(), null); }
         set { SetOutputConsumer(value); }  //i.e.: set { OutputConsumer = (tpl, gc) => value(tpl?.Item1.Text) ; }
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This is the universal overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method.
      /// It may be used in case of any output to multiple targets when access to the global cache is needed.
      /// In most practical scenarios, other overloads are more suitable (easier to implement).
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes 2 parameters: (1) a tuple containing an ExternalLine object and a source number, and (2) a reference to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((Tuple&lt;ExternalLine, int&gt; tpl, IGlobalCache gc) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(tpl As Tuple(Of ExternalLine, Integer), gc As IGlobalCache) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<Tuple<ExternalLine, int>, IGlobalCache> consumerToSet)
      {
         OutputConsumer = consumerToSet;
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of any output to multiple targets and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes a single parameter: a tuple containing an ExternalLine object and a corresponding target number.
      /// The action has no access to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((Tuple&lt;ExternalLine, int&gt; tpl) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(tpl As Tuple(Of ExternalLine, Integer)) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<Tuple<ExternalLine, int>> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of any output to a single target when access to the global cache is needed.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes 2 parameters: (1) an ExternalLine object, and (2) a reference to global cache.
      /// The action is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((ExternalLine l, IGlobalCache gc) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(l As ExternalLine, gc As IGlobalCache) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<ExternalLine, IGlobalCache> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl?.Item1, gc);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method can be used in case of any output to a single target and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes a single parameter containing an ExternalLine object.
      /// The action has no access to global cache and is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((ExternalLine l) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(l As ExternalLine) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<ExternalLine> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl?.Item1);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to multiple targets when access to the global cache is needed.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes 2 parameters: (1) a tuple containing a line of text and a corresponding target number, and (2) a reference to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((Tuple&lt;string, int&gt; tpl, IGlobalCache gc) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(tpl As Tuple(Of String, Integer), gc As IGlobalCache) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<Tuple<string, int>, IGlobalCache> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl.ToTextTuple(), gc);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to multiple targets and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes a single parameter: a tuple containing a line of text and a corresponding target number.
      /// The action has no access to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((Tuple&lt;string, int&gt; tpl) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(tpl As Tuple(Of String, Integer)) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<Tuple<string, int>> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl.ToTextTuple());
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to a single target when access to the global cache is needed.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes 2 parameters: (1) a line of text, and (2) a reference to global cache.
      /// The action is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((string l, IGlobalCache gc) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(l As String, gc As IGlobalCache) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<string, IGlobalCache> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl?.Item1.Text, gc);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to a single target and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes a single parameter containing a line of text.
      /// The action has no access to global cache and is suitable in case of a single target (it will direct all output to target number 1).</param>
       /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((string l) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(l As String) ... )</code>
      /// </remarks>
      public void SetOutputConsumer(Action<string> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl?.Item1.Text);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of record-centric output to multiple targets when access to the global cache is needed.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes 2 parameters: (1) a tuple containing a tuple containing a record expressed as a sequence of key-value pairs and a corresponding target number, and (2) a reference to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((Tuple&lt;IEnumerable&lt;Tuple&lt;string, object&gt;&gt;, int&gt; tpl, IGlobalCache gc) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(tpl As Tuple(Of IEnumerable(Of Tuple(Of String, Object)), Integer), gc As IGlobalCache) ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetOutputConsumer(Action<Tuple<IEnumerable<Tuple<string, object>>, int>, IGlobalCache> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl.ToRecordTuple(), gc);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of record-centric output to multiple targets and no need to access the global cache.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes a single parameter: a tuple containing a record expressed as a sequence of key-value pairs and a corresponding target number.
      /// The action has no access to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((Tuple&lt;IEnumerable&lt;Tuple&lt;string, object&gt;&gt;, int&gt; tpl) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(tpl As Tuple(Of IEnumerable(Of Tuple(Of String, Object)), Integer)) ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetOutputConsumer(Action<Tuple<IEnumerable<Tuple<string, object>>, int>> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl.ToRecordTuple());
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of record-centric output to a single target when access to the global cache is needed.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes 2 parameters: (1) a record expressed as a sequence of key-value pairs, and (2) a reference to global cache.
      /// The action is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((IEnumerable&lt;Tuple&lt;string, object&gt;&gt; rec, IGlobalCache gc) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(rec As IEnumerable(Of Tuple(Of String, Object)), gc As IGlobalCache) ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetOutputConsumer(Action<IEnumerable<Tuple<string, object>>, IGlobalCache> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl?.Item1.Items, gc);
      }


      /// <summary>
      /// Designates an output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetOutputConsumer">SetOutputConsumer</see> method is intended for use in case of record-centric output to a single target and no need to access the global cache.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An action (void function) that takes a single parameter containing a record expressed as a sequence of key-value pairs.
      /// The action has no access to global cache and is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer((IEnumerable&lt;Tuple&lt;string, object&gt;&gt; rec) =&gt; { ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Function(rec As IEnumerable(Of Tuple(Of String, Object))) ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetOutputConsumer(Action<IEnumerable<Tuple<string, object>>> consumerToSet)
      {
         OutputConsumer = (tpl, gc) => consumerToSet(tpl?.Item1.Items);
      }


      /// <summary>
      /// An asynchronous action (Task returning function) that consumes a tuple containing a <see cref="ExternalLine"/> object (a single output line received from Data Conveyer) and the target number (Func&lt;Tuple&lt;string, int&gt;, Task&gt;).
      /// Reference to global cache (<see cref="IGlobalCache"/>) is passed as the second parameter.
      /// The function is intended for use in case of a long-running operation to consume the output line, e.g. await LongRunningOperation(..).
      /// Data Conveyer calls this action (when <see cref="AsyncOutput"/> is true) in succession passing (tuples with) the output lines one at a time.
      /// The last tuple sent by Data Conveyer is always null (end of data mark).
      /// If not defined, Data Conveyer assumes default <see cref="AsyncOutputConsumer"/> action that ignores data passed to it, i.e.:
      /// <code language="c#">(tpl, gc) => Task.CompletedTask</code>
      /// <code language="vb">Function(tpl, gc) Task.CompletedTask</code>
      /// Any exception thrown by this action will cause the process shutdown with a <see cref="CompletionStatus"/> of Failed.
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the output consumer is discouraged. It is recommended to instead call the <see cref="SetAsyncOutputConsumer(Func{Tuple{ExternalLine, int}, IGlobalCache, Task})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method that better suit many output scenarios.
      ///</remarks>
      [XmlIgnore]
      public Func<Tuple<ExternalLine, int>, IGlobalCache, Task> AsyncOutputConsumer { get; set; }


      /// <summary>
      /// An asynchronous action (Task returning function) that consumes a single line of text received from Data Conveyer. (Func&lt;string, Task&gt;).
      /// The last line sent by Data Conveyer is always null (end of data mark).
      /// The <see cref="AsyncTextOutputConsumer"/> action is a simplified version of the <see cref="AsyncOutputConsumer"/> action where the following restrictions apply:
      /// <list type="bullet">
      /// <item>Output data kind is textual such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc. (and not for example <see cref="KindOfTextData.XML"/>).</item>
      /// <item>All lines are sent to a single target (regardless of the target determined by the <see cref="ClusterRouter"/> function).</item>
      /// <item>No access to global cache.</item>
      /// </list>
      /// </summary>
      /// <remarks>
      /// Use of this setting to designate the output consumer is discouraged. It is recommended to instead call the <see cref="SetAsyncOutputConsumer(Func{string, Task})"/> method,
      /// which is functionally equivalent. There are additional overloads of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method that better suit many output scenarios.
      ///</remarks>
      [XmlIgnore]
      public Func<string, Task> AsyncTextOutputConsumer
      {
         //translate between Func<string, Task> and Func<Tuple<ExternalLine, int>, IGlobalCache, Task>
         get { return async s => await AsyncOutputConsumer(s?.ToExternalTuple(), null); }
         set { SetAsyncOutputConsumer(value); }  //i.e.: set { AsyncOutputConsumer = async(tpl, gc) => await value(tpl?.Item1.Text); }
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This is the universal overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method.
      /// It may be used in case of any output to multiple targets when access to the global cache is needed.
      /// In most practical scenarios, other overloads are more suitable (easier to implement).
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes 2 parameters: (1) a tuple containing an ExternalLine object and a source number, and (2) a reference to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (Tuple&lt;ExternalLine, int&gt; tpl, IGlobalCache gc) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(tpl As Tuple(Of ExternalLine, Integer), gc As IGlobalCache) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<Tuple<ExternalLine, int>, IGlobalCache, Task> consumerToSet)
      {
         AsyncOutputConsumer = consumerToSet;
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of any output to multiple targets and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes a single parameter: a tuple containing an ExternalLine object and a corresponding target number.
      /// The action has no access to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (Tuple&lt;ExternalLine, int&gt; tpl) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(tpl As Tuple(Of ExternalLine, Integer)) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<Tuple<ExternalLine, int>, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of any output to a single target when access to the global cache is needed.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes 2 parameters: (1) an ExternalLine object , and (2) a reference to global cache.
      /// The action is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (ExternalLine l, IGlobalCache gc) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(l As ExternalLine, gc As IGlobalCache) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<ExternalLine, IGlobalCache, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl?.Item1, gc);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of any output to a single target and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes a single parameter containing an ExternalLine object.
      /// The action has no access to global cache and is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (ExternalLine l) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(l As ExternalLine) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<ExternalLine, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl?.Item1);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to multiple targets when access to the global cache is needed.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes 2 parameters: (1) a tuple containing a line of text and a corresponding target number, and (2) a reference to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (Tuple&lt;string, int&gt; tpl, IGlobalCache gc) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(tpl As Tuple(Of String, Integer), gc As IGlobalCache) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<Tuple<string, int>, IGlobalCache, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl.ToTextTuple(), gc);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to multiple targets and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes a single parameter: a tuple containing a line of text and a corresponding target number.
      /// The action has no access to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (Tuple&lt;string, int&gt; tpl) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(tpl As Tuple(Of String, Integer)) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<Tuple<string, int>, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl.ToTextTuple());
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to a single target when access to the global cache is needed.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes 2 parameters: (1) a line of text, and (2) a reference to global cache.
      /// The action is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (string l, IGlobalCache gc) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(l As String, gc As IGlobalCache) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<string, IGlobalCache, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl?.Item1.Text, gc);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of textual output (such as <see cref="KindOfTextData.Delimited"/>, <see cref="KindOfTextData.Flat"/>, etc.) to a single target and no need to access the global cache.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes a single parameter containing a line of text.
      /// The action has no access to global cache and is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (string l) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(l As String) ... Await ... )</code>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<string, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl?.Item1.Text);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of record-centric output to multiple targets when access to the global cache is needed.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes 2 parameters: (1) a tuple containing a tuple containing a record expressed as a sequence of key-value pairs and a corresponding target number, and (2) a reference to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (Tuple&lt;IEnumerable&lt;Tuple&lt;string, object&gt;&gt;, int&gt; tpl, IGlobalCache gc) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(tpl As Tuple(Of IEnumerable(Of Tuple(Of String, Object)), Integer), gc As IGlobalCache) ... Await ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<Tuple<IEnumerable<Tuple<string, object>>, int>, IGlobalCache, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl.ToRecordTuple(), gc);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of record-centric output to multiple targets and no need to access the global cache.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes a single parameter: a tuple containing a record expressed as a sequence of key-value pairs and a corresponding target number.
      /// The action has no access to global cache.</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (Tuple&lt;IEnumerable&lt;Tuple&lt;string, object&gt;&gt;, int&gt; tpl) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(tpl As Tuple(Of IEnumerable(Of Tuple(Of String, Object)), Integer)) ... Await ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<Tuple<IEnumerable<Tuple<string, object>>, int>, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl.ToRecordTuple());
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of record-centric output to a single target when access to the global cache is needed.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes 2 parameters: (1) a record expressed as a sequence of key-value pairs, and (2) a reference to global cache.
      /// The action is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (IEnumerable&lt;Tuple&lt;string, object&gt;&gt; rec, IGlobalCache gc) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(rec As IEnumerable(Of Tuple(Of String, Object)), gc As IGlobalCache) ... Await ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<IEnumerable<Tuple<string, object>>, IGlobalCache, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl?.Item1.Items, gc);
      }


      /// <summary>
      /// Designates an asynchronous output consumer action.
      /// This overload of the <see cref="O:Mavidian.DataConveyer.Orchestrators.OrchestratorConfig.SetAsyncOutputConsumer">SetAsyncOutputConsumer</see> method is intended for use in case of record-centric output to a single target and no need to access the global cache.
      /// To use this overload, the <see cref="OutputDataKind"/> setting must be either <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>. See the note below for differences between these two kinds.
      /// </summary>
      /// <param name="consumerToSet">An asynchronous action (task-returning function) that takes a single parameter containing a record expressed as a sequence of key-value pairs.
      /// The action has no access to global cache and is suitable in case of a single target (it will direct all output to target number 1).</param>
      /// <remarks>
      /// When the method parameter (the <c>consumerToSet</c> action) is expressed using lambda expression, it may be necessary to disambiguate the type of the actions's argument; for example:
      /// <code language="c#">config.SetOutputConsumer(async (IEnumerable&lt;Tuple&lt;string, object&gt;&gt; rec) =&gt; { ... await ... });</code>
      /// <code language="vb">config.SetOutputConsumer(Async Function(rec As IEnumerable(Of Tuple(Of String, Object))) ... Await ... )</code>
      /// <note type="note">
      /// <para>Data passed by Data Conveyer to this action (i.e. the "record expressed as a sequence of key-value pairs") is shaped differently depending on the <see cref="OutputDataKind"/> setting.</para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, values for all fields are converted to string type with the format (if any specified in <see cref="ExplicitTypeDefinitions"/> or <see cref="TypeDefiner"/>) applied.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, values for all fields except for those of the <see cref="ItemType.DateTime"/> type, are passed in their native type and no format gets applied.
      /// However, values for fields of the <see cref="ItemType.DateTime"/> type are converted to strings with the format applied (just like in case of <see cref="KindOfTextData.XML"/>).
      /// <i>This behavior derives from the JSON standard, which provides native support for data types handled by Data Conveyer, except for the <see cref="ItemType.DateTime"/> type.</i>
      /// </para>
      /// </note>
      /// </remarks>
      public void SetAsyncOutputConsumer(Func<IEnumerable<Tuple<string, object>>, Task> consumerToSet)
      {
         AsyncOutputConsumer = async (tpl, gc) => await consumerToSet(tpl?.Item1.Items);
      }


      /// <summary>
      /// A function intended to initialize any output targets (such as open files or database connections) and related resources that may be needed by the <see cref="TextOutputConsumer"/> or <see cref="AsyncTextOutputConsumer"/> action.
      /// Data Conveyer calls this function a single time before starting the actual orchestrator processing, such as  invocations of <see cref="TextOutputConsumer"/> function if one is defined.
      /// However, if <see cref="TextOutputConsumer"/> or <see cref="AsyncTextOutputConsumer"/> action is not defined; then this function is not called.
      /// The <see cref="OutputInitializer"/> function accepts a single parameter (<see cref="IGlobalCache"/>) and returns a string (Func&lt;string&gt;).
      /// Null returned value means successful initialization; otherwise, an error message indicating reason for the failure is expected to be returned (Data Conveyer will log this message).
      /// This function may remain not called in case of failure of prior initializer (<see cref="IntakeInitializer"/>), in which case the processing will result in the <see cref="CompletionStatus.InitializationError"/> status.
      /// If not defined, default <see cref="OutputInitializer"/> function simply returns null, i.e.:
      /// <code language="c#">gc => null</code>
      /// <code language="vb">Function(gc) Nothing</code>
      /// </summary>
      [XmlIgnore]
      public Func<IGlobalCache, string> OutputInitializer { get; set; }


      /// <summary>
      /// An action intended to dispose any output targets and related resources that were opened by the <see cref="OutputInitializer"/> function.
      /// Data Conveyer calls this action a single time after completing orchestrator processing (when the orchestrator is disposed).
      /// However, if <see cref="TextOutputConsumer"/> or <see cref="AsyncTextOutputConsumer"/> action is not defined; then this function is not called.
      /// The <see cref="OutputDisposer"/> action accepts a single parameter (<see cref="IGlobalCache"/>) and returns void (Action&lt;IGlobalCache&gt;).
      /// If not supplied, Data Conveyer assumes empty action, i.e.:
      /// <code language="c#">gc => { }</code>
      /// <code language="vb">
      /// Sub(gc)
      /// End Sub
      /// </code>
      /// Any exception thrown by this function will be logged, but otherwise ignored.
      /// </summary>
      [XmlIgnore]
      public Action<IGlobalCache> OutputDisposer { get; set; }


      /// <summary>
      /// Ratio between sizes of the output buffer and the transformer's input buffer (transformer's input buffer size is defined by the <see cref="BufferSize"/> setting).
      /// This advanced setting allows fine-tuning of memory consumption by Data Conveyer.
      /// For example, if an average cluster on output is expected to produce 5 output records (and also on average every other cluster to be removed by the transformer),
      ///  it may be sensible to set the transformer's input buffer size to 100 clusters (transformer's output buffer size to 50 clusters)
      ///  and the output buffer size to 250 clusters.  In this case, <see cref="BufferSize"/> = 100 and <see cref="OutputBufferFactor"/> = 2.5.
      /// Default value for <see cref="IntakeBufferFactor"/> is 1.5.
      /// This setting is respected only if <see cref="BufferSize"/> is set to a positive value (i.e. ignored in case of <see cref="BufferSize"/>'s default value of -1 (Unlimited)).
      /// </summary>
      public double OutputBufferFactor { get; set; }


      /// <summary>
      /// True means 1st line sent to output will contain field names and data will start on the 2nd line; false (default) means no field names are sent to output and data starts on the 1st line. 
      /// This setting applies only to data kinds that support header rows, such as <see cref="KindOfTextData.Delimited"/> or <see cref="KindOfTextData.Flat"/>; otherwise, it is  ignored, in which case data always starts on the 1st line.
      /// </summary>
      public bool HeadersInFirstOutputRow { get; set; }


      /// <summary>
      /// Relevant only if multiple output targets are present and <see cref="HeadersInFirstOutputRow"/> is true.
      /// If true (default), then the header row will be sent to all output targets before sending data rows.
      /// If false, then the header row will only be sent the first output target (typically the one with TargetNo=1, but it can actually be any target).
      /// <i>Note that all output targets are subjected to the same set of processing rules, which implies that the same header row applies to all targets regardless if it's repeated for all sources or not.</i>
      /// </summary>
      public bool RepeatOutputHeaders { get; set; }


      /// <summary>
      /// Specifies which values are to be surrounded with quotes on output. One of:
      /// OnlyIfNeeded - Output values are not quoted, except for those that contain commas and/or quotes (default).
      /// StringsAndDates - String and date values are quoted on output, while decimal or integer values are not (except if formatted to contain commas).
      /// Always - All values are surrounded with quotes on output.
      /// </summary>
      public QuotationMode QuotationMode { get; set; }


      /// <summary>
      /// True means that leading and trailing spaces will be trimmed from output values. False (default) means that all spaces are preserved.
      /// Values get trimmed before surrounding in quotes (per <see cref="QuotationMode"/> setting).
      /// </summary>
      public bool TrimOutputValues { get; set; }


      /// <summary>
      /// Prefix to be prepended to every key on <see cref="KindOfTextData.Keyword"/> output (e.g. @p).
      /// </summary>
      public string OutputKeyPrefix { get; set; }


      /// <summary>
      /// <para>
      /// Comma delimited list of fields to appear on output lines.
      /// Each field is defined by a name and width, separated by a pipe (|) symbol.
      /// Once this setting is specified, only those fields specified can be included in output.
      /// </para>
      /// <para>
      /// This setting is optional. However, it can only be omitted in its entirety, in which case all fields produced by transformation will be included in output.
      /// If the setting is present, then each field name must be specified (no default names can be assumed [unlike <see cref="InputFields"/>]).
      /// If a name of a non-existing field is specified, then empty contents is sent to output for such field.
      /// </para>
      /// <para>
      /// Field widths are only applicable to <see cref="KindOfTextData.Flat"/> (fixed width) data output; they are ignored for other kinds of output data.
      /// Where omitted or invalid, a default width (<see cref="DefaultOutputFieldWidth"/>) is assumed.
      /// </para>
      /// </summary>
      public string OutputFields { get; set; }


      /// <summary>
      /// Character that separates fields on output lines. Only applicable to Delimited and Keyword data, ignored in case of other data kinds.
      /// If not specified, a comma is assumed.
      /// </summary>
      public char OutputFieldSeparator { get; set; }


      /// <summary>
      /// Array of strings that define data to be placed in output lines.
      /// Each string contains a fragment of output line and may contain a single token in a form of {field}, where
      /// such token will be substituted in the output record by the actual value of the field.
      /// In order to include brace characters in the output, they need to be escaped (preceded by a backslash), like so: \{ and \}.
      /// Note though that backslash characters inside C# string literals may need to be escaped themselves.
      /// For example: "\\{ "Format":"JSON" \\}" or @"\{ "Format":"JSON" \}" will both output identical JSON string.
      /// This setting is mandatory for <see cref="OutputDataKind"/> of Arbitrary; if specified for other data kinds, it is ignored.
      /// </summary>
      public string[] ArbitraryOutputDefs { get; set; }


      /// <summary>
      /// Default width of fields in the flat output data; applicable only if <see cref="OutputDataKind"/> is Flat, ignored otherwise.
      /// If not specified, a default width of 10 is assumed.
      /// </summary>
      public int DefaultOutputFieldWidth { get; set; }


      /// <summary>
      /// Data, if any, to be sent to output before the first output line; may be multi-line.
      /// In case the header row is also present, then it will follow the leader contents.
      /// </summary>
      public string LeaderContents { get; set; }


      /// <summary>
      /// Relevant only if multiple output targets are present and <see cref="LeaderContents"/> is not null.
      /// If true (default), then the trailer rows will be send to all output targets after sending data rows.
      /// If false, then the trailer rows  will only be sent the last output target (typically the one with the highest TargetNo, but it can actually be any target).
      /// </summary>
      public bool RepeatLeaders { get; set; }


      /// <summary>
      /// Data, if any, to be sent to output after the last output line; may be multi-line.
      /// </summary>
      public string TrailerContents { get; set; }


      /// <summary>
      /// Relevant only if multiple output targets are present and <see cref="TrailerContents"/> is not null.
      /// If true (default), then the trailer rows will be send to all output targets after sending data rows.
      /// If false, then the trailer rows  will only be sent the last output target (typically the one with the highest TargetNo, but it can actually be any target).
      /// </summary>
      public bool RepeatTrailers { get; set; }


      /// <summary>
      /// <para>
      /// In case of <see cref="KindOfTextData.Delimited"/> or <see cref="KindOfTextData.Flat"/> output data, this setting, when true, causes
      /// Data Conveyer to remove trailing, insignificant fields, i.e. fields with empty values (in addition, trailing spaces on the last field are removed);
      ///   if false (default), then all fields are always included on output (in their entirety).
      /// <para>
      /// </para>
      /// For <see cref="KindOfTextData.Keyword"/> output data, the setting is only applicable when <see cref="OutputFields"/> setting is specified.
      ///   If true, only those fields that are both: specified in <see cref="OutputFields"/> and also present in the actual records will be included on output.
      ///   If false (default), all fields will always be included on output (empty values assumed for fields absent from the actual records).
      ///   </para>
      /// </summary>
      public bool ExcludeExtraneousFields { get; set; }


      /// <summary>
      /// A string containing comma separated parameters for writing <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/> data on output.
      /// Each such parameter is a key-value pair with a pipe symbol (|) separating the key and the value.
      /// The parameters define the shape of data to write.
      /// There are some differences (explained below) in their interpretation in case of <see cref="KindOfTextData.XML"/> vs <see cref="KindOfTextData.JSON"/>.
      /// The following keys can be used:
      /// <list type="bullet">
      ///   <item>
      ///     <term>CollectionNode</term>
      ///     <description>
      ///       "xpath" defining the collection of clusters (or records if the ClusterNode parameter is absent).
      ///       If this parameter is absent for <see cref="KindOfTextData.XML"/>, then output will contain XML fragment where each root constitutes a record or a cluster.
      ///       In case of <see cref="KindOfTextData.JSON"/>, absent or empty value generally means an array instead of an object.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>ClusterNode</term>
      ///     <description>
      ///       "xpath" to the cluster node within the collection node. Records with the same cluster number will be placed inside the same cluster node.
      ///       If this parameter is absent, then all records will be placed directly in the collection node regardless of their cluster number.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>RecordNode</term>
      ///     <description>
      ///       "xpath" to the record node within the cluster node (or the collection node if the cluster node is empty).
      ///       In case of <see cref="KindOfTextData.XML"/> this parameter is required; if absent or empty, a default value of "__record__" will be assumed.
      ///       In case of <see cref="KindOfTextData.JSON"/> this parameter can be empty (or even absent if CollectionNode and ClusterNode are also empty - special case to output multiple objects containing records).
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>AttributeFields</term>
      ///     <description>
      ///       <see cref="KindOfTextData.XML"/> only, ignored in case of <see cref="KindOfTextData.JSON"/>.
      ///       A semi-colon separated list of field names (item keys) to be projected as attributes of the record node (and not inner nodes).
      ///       In addition, all fields with names starting with @ will be projected as attributes of the record node (the @ will not be removed from the attribute name).
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>IndentChars</term>
      ///     <description>
      ///       A string to use when indenting, e.g. "\t" or "  ". This parameter allows to "pretty-print" the output. When absent, no indenting takes place.
      ///       Note that in case of <see cref="KindOfTextData.JSON"/>, the only sensible value for this parameter contains a string containg a single character (possibly repeated,
      ///       e.g. "   " or "\t"; if different characters are used (e.g. " \t" i.e. a space and a tab), then the output may not be as expected.
      ///     </description>
      ///   </item>
      ///   <item>
      ///     <term>NewLineChars</term>
      ///     <description><see cref="KindOfTextData.XML"/> only, ignored in case of <see cref="KindOfTextData.JSON"/>. Characters to use for line breaks (to "pretty-print" the <see cref="KindOfTextData.XML"/> output).</description>
      ///   </item>
      /// </list>
      /// <note type="note">
      /// <para>
      /// "xpath" in any of the node parameters is a simplified version of the xpath syntax.
      /// It is always relative to the containing node (no need for ./).
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.JSON"/>, it contains names of the nodes (nested in the node hierarchy) separated by /.
      /// Empty nodes are allowed, in which case the output at a given hierarchy level consist of an array instead of an object containing an array.
      /// Special case: when CollectionNode, ClusterNode and RecordNode are all absent, then output will consist of multiple objects containing records.
      /// </para>
      /// <para>
      /// In case of <see cref="KindOfTextData.XML"/>, empty nodes are not allowed. In addition, node names must be valid XML names (notes that certain
      /// characters, such as spaces, are not allowed in XML even though they are allowed in JSON).
      /// Attributes can be specified, but must include both name and value. In such cases,
      /// an attribute will be added to the node on output. Care needs to be taken in case of attributes of the record node to avoid name duplicates with the
      /// records fields (when AttributeFields parameter is used).
      /// </para>
      /// </note>
      /// <para><b>Example 1:</b><c>"CollectionNode|Members,RecordNode|Member,IndentChars|  "</c><i>(<see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>)</i></para>
      /// <para><b>Example 2:</b><c>"RecordNode|Member,IndentChars|\t"</c><i>(XML or JSON)</i></para>
      /// <para><b>Example 3:</b><c>"CollectionNode|Root/Members,ClusterNode|Group/Subgroup/Family,RecordNode|Data/Member"</c><i>(<see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>)</i></para>
      /// <para><b>Example 4:</b><c>"RecordNode|,IndentChars|  "</c><i>(<see cref="KindOfTextData.JSON"/> only - an array of object containing records)</i></para>
      /// <para><b>Example 5:</b><c>"ClusterNode|,RecordNode|"</c><i>(<see cref="KindOfTextData.JSON"/> only - an array of arrays=clusters of objects=records)</i></para>
      /// <para><b>Example 6:</b><c>""</c><i>(JSON only - all node parameters absent is a special case that results in multiple objects containing records)</i></para>
      /// <para><b>Example 7:</b><c>"CollectionNode|Root/Members[@region=North],ClusterNode|Group[@id=2][@zone=\"\"]/Family,RecordNode|Data/Member[@class=\"main\"],AttributeFields|ID;zone"</c><i>(<see cref="KindOfTextData.XML"/> only)</i></para>
      /// <para>This configuration setting is only applicable when <see cref="OutputDataKind"/> value is <see cref="KindOfTextData.XML"/> or <see cref="KindOfTextData.JSON"/>.</para>
      /// </summary>
      public string XmlJsonOutputSettings { get; set; }

#endregion Output specific settings


#region Static methods to save and restore configuration

      /// <summary>
      /// Save current configuration setting into an XML configuration file.
      /// Note that only non-executable settings are saved; functions cannot be saved this way.
      /// Instead, functions can be contained in the a ConfigFunctions class of a separate project.
      /// </summary>
      /// <param name="configPath">Name of the configuration to save, which is the same as the file name without .cfg extension and may be preceded by a path (absolute or relative).</param>
      /// <returns>True if the XML file successfully crated; false otherwise.</returns>
      public bool SaveConfig(string configPath)
      {
         try
         {
            File.WriteAllText(configPath + ".cfg", this.ToXML());  //ToXML serializes object using XML serializer
         }
         catch (Exception ex)
         {
            this.Logger.LogError($"{ ex.GetType().Name } occurred when saving configuration data: '{ ex.Message}'.");
            if (CloseLoggerOnDispose)  // special meaning of the CloseLoggerOnDispose setting
            {
               this.Logger.LogEnd();
               this.Logger.Dispose();
            }
            return false;
         }
         this.Logger.LogInfo($"Configuration {configPath} successfully saved.");
         return true;
      }


      /// <summary>
      /// A factory method to create a configuration instance from saved configuration settings.
      /// The configuration consists of 1 or 2 files: a .cfg file (required) containing configuration data in XML format (as saved by the <see cref="SaveConfig"/> method),
      /// and a .dll file (optional) containing executable code, i.e. static functions named the same as the corresponding configured delegates (e.g. <see cref="TypeDefiner"/> or <see cref="ClusterMarker"/>).
      /// The DLL must be built as standalone .NET class library project using Visual Studio (or equivalent). The project must reference the current version of
      /// Data Conveyer (so, it must be rebuilt with each upgrade). The functions must be placed in a static class named ConfigFunctions.
      /// Both files (.cfg and .dll) must be placed in the same folder as DataConveyer.dll.
      /// </summary>
      /// <param name="configPath">Name of the configuration to restore, which is the same as the names of the files with configuration data, but without .cfg/.dll extension.
      /// It may be preceded by a path (absolute or relative).</param>
      /// <param name="logger">Logger to be used to process log entries generated by Data Conveyer, such as warnings or errors. If omitted, a <see cref="LoggerType.Null"/> logger will be assumed.</param>
      /// <returns>The restored configuration instance or null in case of failure.</returns>
      public static OrchestratorConfig RestoreConfig(string configPath, ILogger logger = null)
      {
         var configName = Path.GetFileNameWithoutExtension(configPath);
         if (logger == null) logger = LoggerCreator.CreateLogger();  // null logger
         logger.LogStart(configName);

         logger.LogInfo($"Restoring {configName} configuration...");

         OrchestratorConfig retVal = null;
         try
         {
            retVal = File.ReadAllText(configPath + ".cfg").ToObject<OrchestratorConfig>();
            //ToObject deserializes OrchestratorConfig object. Note that ToObject uses default ctor and hence null Logger,
            // which will be discarded below and replaced by the actual logger below (once we know RestoreConfig succeeded).
         }
         catch (Exception ex)
         {
            logger.LogFatal($"{ ex.GetType().Name } occurred when restoring {configName} configuration: '{ex.Message}'\r\nNo configuration restored.");
            logger.LogEnd();
            logger.Dispose();
            return null;
         }

         retVal.ConfigName = configName;

         //Obtain configuration functions from DLL.
         var messages = AddFunctionsFromDLL(ref retVal, configPath); //this function updates functions in retVal (possibly even sets it to null - if bad DLL file)

         if (retVal == null)
         {  //here, messages contains a single fatal error; strip 1st character (which must be an F)
            Debug.Assert(messages[0][0] == 'F');
            logger.LogFatal(messages[0].Substring(1));
            logger.LogEnd();
            logger.Dispose();
         }
         else
         {  //here, we have the config object to return
            retVal.Logger = logger;
            //we may have an empty message list or error(s)/warning(s)
            messages.ForEach(m => { if (m[0] == 'E') logger.LogError(m.Substring(1)); else if (m[0] == 'W') logger.LogWarning(m.Substring(1)); else logger.LogInfo(m.Substring(1)); });
            if (messages.Any(m => m[0] != 'I'))
               logger.LogInfo($"Configuration {configName} restored with " + (messages[0][0] == 'W' ? "warning(s)." : "error(s)."));
            else
               logger.LogInfo($"Configuration {configName} successfully restored.");
         }

         return retVal;
      }

#endregion Static methods to save and restore configuration


#region Private methods

      /// <summary>
      /// Obtain configuration functions from DLL.
      /// </summary>
      /// <param name="config">Orchestrator configuration object to have function settings updated; will be set to null in case of error during execution.</param>
      /// <param name="configPath">Configuration name to determine the DLL assembly file. It may be preceded by a path (absolute or relative).</param>
      /// <returns>A list of messages containing possible messages from the method execution - first letter is always F, E, W or I to denote Fatal, Error, Warning or Info.</returns>
      private static List<string> AddFunctionsFromDLL(ref OrchestratorConfig config, string configPath)
      {
         //Note that the DLL must be built with reference to the current version of DataConveyer.dll, i.e. this one (!)
         //Otherwise, the types defined here (e.g. IRecord) will not match, in which case the code below will assign non-matching functions to the delegates.
         //This will result in runtime errors causing the pipeline shutdown; e.g. MissingMethodException Method not found: 'System.Object Mavidian.DataConveyer.Entities.KeyVal.IRecord.A(System.String)

         var configName = config.ConfigName;
         var absolutePath = new FileInfo(configPath + ".dll").FullName;  // note that Assembly.LoadFile (unlike File.ReadAllText) requires absolute (and not relative) path.

         Type configFunctions;
         try
         {
            configFunctions = Assembly.LoadFile(absolutePath).GetType(configName + ".ConfigFunctions", true);
         }
         catch (FileNotFoundException)  //OK (warning) if DLL file missing (just no custom functions, i.e. all defaults)
         {
            return Enumerable.Repeat($"WThe {absolutePath} file was not found. All functions will remain default.", 1).ToList();
         }
         catch (Exception ex)
         {
            //DLL found, but unexpected contents; e.g. TypeLoadException "Could not load type '...ConfigFunctions' from assembly..."
            config = null;
            return Enumerable.Repeat($"F{ex.GetType().Name} occurred when loading the {absolutePath} file. The file may be corrupted.\r\nNo {configName} configuration restored.", 1).ToList();
         }

         var messages = new List<string>();

         //All public functions in ConfigFunctions class will be considered
         // (they all must be static and have the matching signature (i.e. same as in this OrchestratorConfig class)
         foreach (var funToSet in configFunctions.GetMethods().Where(m => m.DeclaringType == configFunctions && m.IsPublic))
         {
            var funcName = funToSet.Name;
            var configProp = typeof(OrchestratorConfig).GetProperty(funcName);  //null if there is no such setting in OrchestratorConfig (funToSet will be ignored)
            try
            {
               configProp.SetValue(config, funToSet.CreateDelegate(configProp.PropertyType));
               messages.Add($"ISuccessfully restored {funToSet.Name} function.");
            }
            catch (NullReferenceException ex)
            {
               messages.Add($"E{ex.GetType().Name} occurred when restoring {funcName} function: '{ex.Message}'. Is {funcName} an existing configuration setting?");
            }
            catch (ArgumentException ex)
            {
               // ArgumentException "Cannot bind to the target method because its signature or security transparency is not compatible with that of the delegate type." if signature mismatch.
               messages.Add($"E{ex.GetType().Name} occurred when restoring {funcName} function: '{ex.Message}'. Does the method signature match the type of the {funcName} configuration setting?");
            }
            catch (Exception ex)
            {
               messages.Add($"E{ex.GetType().Name} occurred when restoring {funcName} function: '{ex.Message}'");
            }
         }

         return messages;
      }

#endregion Private methods

   }
}